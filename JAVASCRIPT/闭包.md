---
title: 闭包
categories: 
- JAVASCRIPT
---

# 第一类公民

在ECMAScript中，函数是“第一类”对象。


这个名词意味着函数可以作为参数被传递给其他函数使用 (在这种情况下，函数被称为“funargs”——“functional arguments”

funargs示例
```
var a=1;
function closure(){
    console.log(a);
}

function caller(arg){
    var a=2;
    arg();
}
caller(closure);

```

其他函数的运行时也会返回函数，这些返回的函数被称为 function valued 函数 


functional values示例代码

```
function caller(){
    var a=1;
    return function (){
        console.log(a);
    }
}

var closure=caller();
```

这两种情况，都有一个问题

`函数创建和函数调用，不在同一个作用域中，以哪个为准?`

js的解决方式就是在`函数创建的时候，就保存父级变量[[scope]](父级变量对象的引用)`,也就是按照创建的作用域为准

这个时候函数的scope chain只有`父级变量对象的引用[[scope]]`

如果函数执行了，才会创建活动对象

# 静态作用域

A closure is a combination of a code block (in ECMAScript this is a function) and statically/lexically saved all parent scopes.
Thus, via these saved scopes a function may easily refer free variables.
闭包是一系列代码块（在ECMAScript中是函数），并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。

这里有一个静态作用域的概念，也就是说，函数创建的时候就保存外部变量

当然，也有`动态作用域`的概念，但是js没有实现,有些语言有

动态作用域的意思就是:创建的时候不保存外部变量，运行的时候再保存


> 因为每一个普通函数在创建时保存了[[Scope]]，理论上，ECMAScript中所有函数都是闭包。







## 闭包（closure）是定义在某个作用域中的函数


```
function a(){
    var b=function(){
        console.log('bbbbb');
    }
    return b;
}

```
# 闭包优势
- 安全，只有通过返回的对象才可以操作闭包中的内容
- 让变量始终保持在内存中



# 缺点
- 可能导致内存泄漏

# 为什么js会出现这种怪异的东西

作用域链，垃圾回收机制




# 闭包作用
- 减少全局变量
- 隐藏变量
=====>构造模块