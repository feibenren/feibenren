---
title: HTTP-CACHE
categories:
- NETWORK
---

# 策略

使用缓存，可以大大提高效率

但是如何使用缓存，这里有两个主要问题

> 使用发送方(浏览器)和回复方(服务器)表示缓存的两方

### 1、怎么样实现缓存？

这个主要是发送方的事情，接收到数据保存到本地，再次请求该数据就直接使用本地的数据，不用再次发送请求了

### 2、怎么样提高缓存效率？

实现缓存简单，但是提交缓存效率就麻烦了

为了提高缓存效率，双方都应该有对应的`提高缓存效率的机制`才可以

1、发送方`再次`发送请求之前应该知道这个资源是不是被缓存了，也就是`过期机制`

通过这种机制，可以确保接收方这边的`缓存效率(命中率)`是最高的

2、回复方应该有一种`验证机制`来确定是否有必要`再次`回复数据

通过这种方法，可以确保回复方的`缓存效率`是最高的

-------------

这里的发送方就是浏览器，回复方就是服务器







在缓存具体怎么实现的这个问题上，发送方需要和回复方协商好

# 初级版本(http 1.0)

这个版本只有发送方的`过期机制`,没有回复方的`验证机制`

`过期机制`思路其实也非常简单，设置一个时间，服务器每次response的时候，带上这个时间

简单流程

刚开始，发送方什么缓存都没有

- 1、发送方发送一个资源a请求
- 2、回复方收到该请求，回复资源a，并携带一个过期时间(使用`Expires`字段,比如`Expires:2018-1-1 1:1:1`)
- 3、发送方收到该回复，将资源a和过期时间缓存起来

如果过了一段时间，如果再次请求这个资源a，发送方应该怎么做?

- 1、首先检查资源a的过期时间有没有到，如果没到，就不发送请求了，这个时候记录应该是(200 from cache)
- 2、如果过期了，就重新发送这个资源请求就可以了


------------

应该还有一个是否使用缓存的开关

解决方式就是添加`Pragma`字段，默认使用缓存，不用添加，如果哪一方不想使用缓存，就携带该字段`Pragma:no-cache`

`Pragma`其实就是一个的开关，这个开关默认是打开的

也就是说

Expires有效:
```
Expires:2018-1-1
```
Expires无效:
```
Pragma:no-cache
Expires:2018-1-1
```


---------------

> 通过两个字段`Expires`,`Pragma`来实现缓存，简单方便，很好理解

这种解决方式是1.0提供的，其实细想还是有很多问题的

- 1、`Expires`的时间，是服务器的时间，如果浏览器的时间和这个时间不匹配怎么办?(`过期机制有瑕疵`)
- 2、如果时间还没到，服务器把数据给修改了，那么浏览器默认岂不是没法获得最新的数据？(`验证机制`)

# 高级版本(http 1.1)

1.1版本就提供了针对1.0版本的这些问题而来的

----------
第一个问题：客户端和服务器端时间不一致的问题

1.1的版本，提供了一个新的思路，直接返回倒计时的秒数来`保鲜`,`Cache-Control:max-age:7200`,就表示保鲜时间就7200s，这样浏览器在收到这个资源的时候，就直接开始计时，时间不到就不重新请求，如果时间到了，就重新请求

------------

同时，1.1版本提供了新的字段来进行缓存控制,`Cache-Control`,来进行控制，这个字段提供的功能很多，可以组合使用

比如`Cache-Control:no-cache`,就表示不使用缓存,替代`Pragma:no-cache`

`Cache-Control:max-age:7200`，替代老版本的`Expires:2018-11-11`字段

还有很多新加的功能

比如`Cache-Control:public`:表示所有域名都可以使用这个缓存

`Cache-Control:Private=[xxx.com]`:表示这个缓存只能指定域名使用

--------------

第二个问题:时间不到，服务器把数据修改了，客户端没有办法获得最新数据

这就是服务器的验证机制

简单流程

1、服务器response数据的时候，携带字段`Last-Modified:2018-11-11`，里面的时间是文件最后一次被修改的时间

2、浏览器在发送资源请求的时候，携带`If-Modified-Since:2018-11-11`，里面携带的时间就是服务器返回的时间
服务器可以非常快速的验证这个修改时间，如果两个时间一样，就返回`304:Not Modified`，不一样就返回数据

----------
按理说通过这两个字段就可以实现缓存协商了，但是还不放心，`如果文件被修改了，但是修改时间没有变化`,针对这种情况，提供了一个`ETag`，一个资源的哈希值，来最终确定数据是否修改，但是计算`ETag`成本比较高的

实现流程

- 服务器返回资源的同时，返回一个`ETag:xxx`的标签
- 浏览器发送请求的时候，携带`If-None-Match:xxx`的标签，用来给服务器验证



--------------
1.1通过以上的方式，实现了现在的缓存机制



# 兼容

为了保持兼容，1.1版本需要兼容1.0

在1.0中，使用`Pragma`，来控制是否使用缓存

1.1中，使用`Cache-Control`来控制

所以，如果这两个字段同时存在，需要按照`Pragma`这个字段来，优先级高

但是现在基本都是1.1版本的

但是服务器还经常有`Expires`这个字段出现，如果有`Cache-Control`的话，`Expires`这个字段就可以忽略了



# 浏览器发起请求的方式

有很多

- 输入url，回车
- 标签栏
- 超链接
- F5
- 右击刷新
- CTRL+F5
- ajax

这些方式，浏览器使用了不同的缓存对策

- 输入url，回车
- 标签栏
- 超链接

针对这三种方式，浏览器是先查看缓存，如果有就不发送请求，如果没有，就发送请求

- F5
- 右击刷新

这两种方式，用户的意思是`重新加载`

浏览器会`无条件发送一次请求`,但是会`携带协商信息`比如`If-Modified-Since`等，会不会返回数据，就看浏览器的判断了


- CTRL+F5

这种方式，用户的意思是`必须获得最新的数据`

浏览器也会`无条件发送一次请求`,并且`不携带任何协商信息`,会被`当作第一次请求来看待`

-----------------------

关于ajax

通过ajax获取的数据，就不好说了，因为ajax可以自由设定缓存机制

`谷歌浏览器，默认是不使用缓存机制的`

# 总结

缓存机制不仅仅是在浏览器里面使用，很多地方都有使用

总的来说，使用缓存可以提交效率，应该使用

核心问题是`如何提高缓存效率`，以上仅仅是浏览器的使用http协议来使用缓存的实现方式而已









# LINKS
- [https://imweb.io/topic/5795dcb6fb312541492eda8c](https://imweb.io/topic/5795dcb6fb312541492eda8c)
- [https://mp.weixin.qq.com/s/qOMO0LIdA47j3RjhbCWUEQ](https://mp.weixin.qq.com/s/qOMO0LIdA47j3RjhbCWUEQ)
- [http://www.alloyteam.com/2016/03/discussion-on-web-caching/](http://www.alloyteam.com/2016/03/discussion-on-web-caching/)