[{"title":"yargs","url":"/2018/08/02/NODEJS/yargs/","content":"\n# yargs\nnode中的传参是process.argv,得到的数据无法直接使用\nyargs的功能就是优化process.argv，方便使用\n\n# 参考链接\n- [http://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html](http://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html)\n","categories":["NODEJS"]},{"title":"进程和线程","url":"/2018/08/02/NODEJS/进程和线程/","content":"\n# 进程和线程\n一个进程可以有多个线程\n\n# 参考链接\n- [https://www.zhihu.com/question/25532384](https://www.zhihu.com/question/25532384)\n\ncluster:新建的是子进程\nchild_process:新建的是子线程\n\nnodejs是单线程单进程的，\n\n一个单核cpu相同时间内只能有一个进程，但是cpu速度非常快，微观时间上是的，但是宏观上来看，由于频繁的切换，那么就会导致看上去一个电脑可以有很多的进程","categories":["NODEJS"]},{"title":"其他","url":"/2018/08/02/NODEJS/其他/","content":"\n# 现在最新的版本(8.11)任然不支持es6的import语法\n```\nimport mod1 from \"./mod1\";\nconsole.log(mod1);\n\n```\n比如这样在node中是会报错的\n\nNode.js 将文件视为CommonJS 模块","categories":["NODEJS"]},{"title":"shelljs","url":"/2018/08/02/NODEJS/shelljs/","content":"# shelljs\n在js中执行shell命令，里面只有常用bash，不是所有的bash\n\n# 参考链接\n- [https://github.com/youngwind/blog/issues/48](https://github.com/youngwind/blog/issues/48)\n","categories":["NODEJS"]},{"title":"URL,URI,encodeURI(),encodeURIComponent()","url":"/2018/08/01/HTML/URL,URI,encodeURI(),encodeURIComponent()/","content":"\n![三者关系](/images/img3.png)\n\n# URI & URL & URN区别\n\n\nURI = Universal Resource Identifier 统一资源标志符\nURL = Universal Resource Locator 统一资源定位符\nURN = Universal Resource Name 统一资源名称\n\n\n\nURI可以分为URL,URN或同时具备locators 和names特性的一个东西\n\n简单的说就是 URI=URN+URL,URI这个东西可以表述一个东西的身份，\n\nURN确定了东西的身份，URL提供了找到它的方式\nURN比如有书的isbn编号，身份证，等等\nURI比如有\n\n\nftp://ftp.is.co.za/rfc/rfc1808.txt (also a URL because of the protocol)\nhttp://www.ietf.org/rfc/rfc2396.txt (also a URL because of the protocol)\nldap://[2001:db8::7]/c=GB?objectClass?one (also a URL because of the protocol)\nmailto:John.Doe@example.com (also a URL because of the protocol)\nnews:comp.infosystems.www.servers.unix (also a URL because of the protocol)\ntel:+1-816-555-1212\ntelnet://192.0.2.16:80/ (also a URL because of the protocol)\nurn:oasis:names:specification:docbook:dtd:xml:4.1.2\n这些全都是URI, 其中有些事URL. 哪些? 就是那些提供了 **访问机制** 的.\n\n\nURL比如有网址，通天这个网址，我就可以找到，定位到一个资源\n\n\n最后“URL”这个术语正在被弃用。所以明智吧少年！\n\n\n\n# 为什么要进行URL编码\n很简单，举个例子\nhttp://www.baidu.com?key1=val1&key2=val2\n这里的&,?://都是有特殊含义的，如果，val1是 `&1&2&`那么这个时候就会有歧义了，所以，为了保证不会产生这些歧义，就需要进行转码\n\n转码后的样子就是\n\n%2E%\n就是两种%号，中间是十六的两个字符\n\n```\nhttp%3A%2F%2Fwww.w3school.com.cn\n```\n类似这种效果\n\n\n\n# encodeURI && encodeURIComponent 区别\n简单说，encodeURIComponent转码更彻底，推荐使用encodeURIComponent\n\n\n\n\n\n\n\n\n","categories":["HTML"]},{"title":"location","url":"/2018/08/01/BOM/location/","content":"\n# location\n\n\n\n# 如果实现修改location的hash，就会执行对应的js\n\nHTML5 新增了hashchange 事件","categories":["HTML"]},{"title":"frameset","url":"/2018/08/01/HTML/frameset/","content":"\n# frameset\n这个标签已经被不推荐使用了，不建议使用，这个地方仅仅是为了看懂别人写的代码\n\n## 基本示例\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>test</title>\n</head>\n<frameset cols=\"30%,50%\">\n    <frame name='f1' src='f1.html'></frame>\n    <frame name='f2' src='f2.html'></frame>\n</frameset>\n</html>\n```\n### 注意\n- 没有body\n- frameset 通过属性来定义比例\n- frameset rows=\"10%,30%\"表示上下布局:上面10%比例，下面30%比例\n- frameset cols:左右布局\n- frame默认都是100%高度这个很有用\n- 每个frame 通过name来标示自己\n\n### frameset 中window的三种表示方法: top,self,parent\ntop:如果在一个frame中，top就表示最顶层,最外围的window\nself:表示frame中的自己 ，其实，self===window 只是为了与top，parent对应一下\nparent:表示自己的父级window,\n\n","categories":["HTML"]},{"title":"window","url":"/2018/08/01/JAVASCRIPT/window/","content":"\n```\nvar a=111;\nconsole.log(window.a)\n```\n如果在浏览器中，会输出什么？\nundefined?   111?\n会输出111\n由于window 对象同时扮演着ECMAScript 中Global 对象的角色，因此所有在全局作用域中声明\n的变量、函数都会变成window 对象的属性和方法\n\n\n```\nvar a=111;\nconsole.log(global.a)\n```\n如果是nodejs环境中呢？？？？\n**会报错**\n\n为什么呢？\n很简单\n按照 ECMAScript 的定义，满足以下条 件的变量是全局变量\n- 在最外层定义的变量；\n- 全局对象的属性；//setinterval,console等\n- 隐式定义的变量（未定义直接赋值的变量）。//__dirname,__filename等\n\n\n需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。\n\n\n\n----------\n出现这种差别的原因就在于nodejs是有模块系统的，申明的变量，都是当前模块的变量，不是全局变量\n而浏览器端不是这种情况\n\n[http://www.runoob.com/nodejs/nodejs-global-object.html](http://www.runoob.com/nodejs/nodejs-global-object.html)\n\n","categories":["JAVASCRIPT"]},{"title":"href && src","url":"/2018/07/26/HTML/href && src/","content":"\n# href\nHypertext Reference\n超文本引用\n\n```\n    <a href=\"\"></a>\n    <link rel=\"stylesheet\" href=\"\">\n```\nhref用于在当前文档和引用资源之间建立联系\n\n\n# src\nsrouce\n源头，地址\n```\n<iframe src=\"\" ></iframe>\n<img src=\"\" alt=\"\">\n<script src=\"\"></script>\n```\n\nsrc用于替换当前元素\n\n\n\n","categories":["HTML"]},{"title":"class语法和原生的区别","url":"/2018/07/21/JAVASCRIPT/class语法和原生的区别/","content":"\n```\nclass Person{\n  constructor(name){\n    this.name=name;\n  }\n  static say(){\n    console.log('Person say...');\n  }\n  eat(){\n    console.log(this.name+' Person eat....')\n  }\n}\nlet p1=new Person('p1');\np1.eat();\n///////////////////等价于\nfunction Human(name){\n  this.name=name;//class中的constructor方法\n}\nHuman.say=function () {//class 中的static的静态方法\n  console.log('human say...')\n}\nHuman.prototype.eat=function(){//class方式申明的所有的函数，都是放到prototype中的\n  console.log(this.name+' human eat...')\n}\nlet h1=new Human('h1');\n// Human.say();\nh1.eat();\n//所以，总的来说，class语法，可以看到可以将构造函数和prototype放到一起写，更直观明了，\n```\n# 参考链接\n[https://github.com/wizardforcel/eloquent-js-3e-zh/blob/master/6.md][https://github.com/wizardforcel/eloquent-js-3e-zh/blob/master/6.md]\n","categories":["JAVASCRIPT"]},{"title":"构造器","url":"/2018/07/19/JAVASCRIPT/构造器/","content":"\n构造对象时使用的原型对象，可以通过构造器的prototype属性来查找。\n\n```\nfunction Person(){\n\n}\nPerson.prototype.name='xxx';//所有构造器都有prototype这个属性(实际上是所有函数)，其他类型的没有，比如对象就没有\n\n\n////////////\n\nlet Dog={};\nDog.prototype.name='eee';//会报错，因为对象没有prototype这个属性\n```","categories":["JAVASCRIPT"]},{"title":"reduce","url":"/2018/07/18/JAVASCRIPT/reduce/","content":"\n## reduce\n归约","categories":["JAVASCRIPT"]},{"title":"深度比较","url":"/2018/07/18/JAVASCRIPT/深度比较/","content":"\n# 深度比较\n\n```\n    function deepCompare(x, y) {\n        var i, l, leftChain, rightChain;\n\n        function compare2Objects(x, y) {\n            var p;\n\n            // remember that NaN === NaN returns false\n            // and isNaN(undefined) returns true\n            if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number') {\n                return true;\n            }\n\n            // Compare primitives and functions.\n            // Check if both arguments link to the same object.\n            // Especially useful on the step where we compare prototypes\n            if (x === y) {\n                return true;\n            }\n\n            // Works in case when functions are created in constructor.\n            // Comparing dates is a common scenario. Another built-ins?\n            // We can even handle functions passed across iframes\n            if ((typeof x === 'function' && typeof y === 'function') ||\n                (x instanceof Date && y instanceof Date) ||\n                (x instanceof RegExp && y instanceof RegExp) ||\n                (x instanceof String && y instanceof String) ||\n                (x instanceof Number && y instanceof Number)) {\n                return x.toString() === y.toString();\n            }\n\n            // At last checking prototypes as good as we can\n            if (!(x instanceof Object && y instanceof Object)) {\n                return false;\n            }\n\n            if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) {\n                return false;\n            }\n\n            if (x.constructor !== y.constructor) {\n                return false;\n            }\n\n            if (x.prototype !== y.prototype) {\n                return false;\n            }\n\n            // Check for infinitive linking loops\n            if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) {\n                return false;\n            }\n\n            // Quick checking of one object being a subset of another.\n            // todo: cache the structure of arguments[0] for performance\n            for (p in y) {\n                if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n                    return false;\n                } else if (typeof y[p] !== typeof x[p]) {\n                    return false;\n                }\n            }\n\n            for (p in x) {\n                if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n                    return false;\n                } else if (typeof y[p] !== typeof x[p]) {\n                    return false;\n                }\n\n                switch (typeof(x[p])) {\n                    case 'object':\n                    case 'function':\n\n                        leftChain.push(x);\n                        rightChain.push(y);\n\n                        if (!compare2Objects(x[p], y[p])) {\n                            return false;\n                        }\n\n                        leftChain.pop();\n                        rightChain.pop();\n                        break;\n\n                    default:\n                        if (x[p] !== y[p]) {\n                            return false;\n                        }\n                        break;\n                }\n            }\n\n            return true;\n        }\n\n        if (arguments.length < 1) {\n            return true; //Die silently? Don't know how to handle such case, please help...\n            // throw \"Need two or more arguments to compare\";\n        }\n\n        for (i = 1, l = arguments.length; i < l; i++) {\n\n            leftChain = []; //Todo: this can be cached\n            rightChain = [];\n\n            if (!compare2Objects(arguments[0], arguments[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n```\n","categories":["JAVASCRIPT"]},{"title":"副作用&&纯函数","url":"/2018/07/18/JAVASCRIPT/副作用&&纯函数/","content":"# 副作用&&纯函数\n\n\n\n","categories":["JAVASCRIPT"]},{"title":"包括开头不包括结尾","url":"/2018/07/18/JAVASCRIPT/包括开头不包括结尾/","content":"# 很多函数的参数都有这个规律\nmath.random()\narr.slice()\narr.splice()\n\n/a{4,8}/\n\n\n","categories":["JAVASCRIPT"]},{"title":"react","url":"/2018/06/30/REACT/react/","content":"\n要渲染一个 React 元素到一个 root DOM 节点，把它们传递给 ReactDOM.render() 方法\n\n\n更新 UI 的唯一方法是创建一个新的元素, 并将其传入 ReactDOM.render() 方法\n\n\n组件名称总是以大写字母开始。\n\n\n一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数\n\n\n所有 React 组件都必须是纯函数，并禁止修改其自身 props\n因为reactor组件都必须是纯函数，所以，不能修改传给该组件的参数，也就是props\n\nprops到底是什么？\n从定义上来说， 组件就像JavaScript的函数。组件可以接收任意输入(称为”props”)， 并返回 React 元素，用以描述屏幕显示内容\n\n\n\n\n唯一可以分配 this.state 的地方是构造函数\n\n当你调用 setState()， React 将合并你提供的对象到当前的状态中\n\n\n键是React的一个内部映射，但其不会传递给组件的内部。如果你需要在组件中使用相同的值，可以明确使用一个不同名字的 prop 传入。\n\n\nJSX允许在大括号中嵌入任何表达式\n\n阅读代码的重要性远远高于写代码\n\n\n\n从本质上讲，JSX 只是为 React.createElement(component, props, ...children) 函数提供的语法糖\n\n\n```\n<MyComponent message=\"hello world\" />\n\n<MyComponent message={'hello world'} />\n//等价的\n\n//当你传递一个字符串字面量时，其值是未转义的 HTML(HTML-unescaped) 。那么这两个 JSX 表达式是等效的：\n<MyComponent message=\"&lt;3\" />\n\n<MyComponent message={'<3'} />\n\n```\n\n\n\nReact 支持给任何组件添加特殊属性。ref 属性接受回调函数，并且当组件 装载(mounted) 或者 卸载(unmounted) 之后，回调函数会立即执行。\n\n\n\nReact 实现了一个独立于浏览器的 DOM 系统，用于提高性能和跨浏览器兼容性。 我们借此机会在浏览器 DOM 实现中清理了一些粗糙的东西","categories":["REACT"]},{"title":"XSS&&CSRF","url":"/2018/06/28/SECURITY/XSS&&CSRF/","content":"# XSS\n\n\n# CSRF\n\n\n\n\n现在对于CSRF的攻击预防比较彻底，一般在没有XSS的前提下，已经很难进行此类攻击了。所以真实的实际操作环境并没有多少。以往主要的攻击手段还是，通过XSS对于cookie进行盗取，然后通过CSRF用户数据进行修改。","categories":["SECURITY"]},{"title":"inquirerjs","url":"/2018/06/26/NODEJS/inquirerjs/","content":"\n# inquirerjs\nnode 互动命令行接口\n\n# 基本用法\n```\nvar inquirer = require('inquirer');\ninquirer\n  .prompt([\n    /* Pass your questions in here */\n  ])\n  .then(answers => {\n    // Use user feedback for... whatever!!\n  });\n\n```","categories":["NODEJS"]},{"title":"noopener","url":"/2018/06/24/HTML/noopener/","content":"\n# noopener\n\n当你使用 target='_blank' 打开一个新的标签页时，新页面的 window 对象上有一个属性 opener，它指向的是前一个页面的 window 对象，因此，后一个页面就获得了前一个页面的控制权，so 可怕！！\n\n\n比如你的链接现在变成了这样 <a href='/index' rel=noopener>链接<a/>，再打开后你会发现 window.opener 已经被置为了 null，如果是一些旧的浏览器，可以使用 rel=noreferrer","categories":["HTML"]},{"title":"ESLINT","url":"/2018/06/24/TOOLS/ESLINT/","content":"# ESLINT\n\n","categories":["TOOLS"]},{"title":"小程序","url":"/2018/06/07/WECHAT/小程序/","content":"\n\n\nWXML 要求标签必须是严格闭合的，没有闭合将会导致编译错误。\n\n\n当 app.js 执行结束后，小程序会按照开发者在 app.json 中定义的 pages 的顺序，逐一执行\n\n\n\n于此同时，我们要特别留意一点，所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理","categories":["WECHAT"]},{"title":"公众号","url":"/2018/06/06/WECHAT/公众号/","content":"\n# 各种坑\n\n## xml 格式\n\n返回 xml 格式的时候，只有格式完全正确才可以正确返回，可用格式化工具检测\n\n## jssdk signature\n\n生成 jssdk 的时候，需要注意的是\ntimestamp：是秒数，不是毫秒数，默认生成的是毫秒数\n\n## jssdk url\n\nurl 一定要完整，正确\n可以使用\n\n```\nlocation.href.split('#')[0]\n```\n\n## JS 接口安全域名\n\n不能含有http://,只能是一个域名，不能带有其他任何东西\n比如:\n\n- http://www.xxx.com\n- http://www.xxx.com/\n- xxx.xxx.com/\n- xxx.xxx.com/index.php\n  以上都不正确\n  没有任何文档提示这点\n\n# JS-SDK 坑\n\n## getLocation，必须点击才可以获取，否则无法获取\n\n# 工具\n\n微信开发者工具 && 微信 WEB 开发者工具是两个工具，不一样,界面都不一样\n微信开发者工具：开发小程序\n微信 WEB 开发者工具：开发基于微信的网页\n","categories":["WECHAT"]},{"title":"用户粘稠度","url":"/2018/05/20/SEO/用户粘稠度/","content":"\n# 互动性\n\n开通博客栏目，让大家可以建立自己的博客，发文章、上传照片、发表观点等，让大家都认识自己，建立自己的圈子，结交更多的朋友。\n\n# 从线下活动\n\n\n\n\n","categories":["SEO"]},{"title":"网站结构分析","url":"/2018/05/19/SEO/网站结构分析/","content":"\n# 门户网站\n\n# 头条\n\n网站:热点，段子，科技，.....一个一个分类，网站首页选出常用分类展示，\n用户:无法自己创建分类\n\n# qq\n和头条类似\n\n# 新浪\n和头条类似\n# 搜索\n和头条类似\n\n# 综上\n门户网站都是一个一个分类，用户只能看，无法做其他的\n\n\n# 社区网站\n\n# 论坛网站\n\n# 社交网站\n\n社区是基于主题，社交是基于关系链\n\n社区的重心在话题（内容），社交（SNS）的重心在关系（人）\n\n社区是人与内容的聚合，社交是互动与沟通（围绕着内容，或者直接）\n\n\n 论坛是社区的一种，其特点是关系松散，一般非实名制。\nsns，微博，轻博客都是社区，但不是论坛。\n\n\n论坛就像一个市中心广场，广场上的人大多不认识，什么样的人都有，但是大家互相交谈，有部分人成为交谈的中心。而社区应该是很多有某种联系的人的沙龙，沙龙里的很多人或者认识，或者大家具有某种共通点。\n\n\n首先，我认为社区和论坛都属于内容产品。\n最明显的区别：内容的组织和分发机制。\n社区中内容隶属于人，由关系链/关注链来分发，是局部封闭和有差异的。\n论坛中内容隶属于子板块，分发是开放而统一的\n\n\n论坛( forum)与社区(community)是BBS(Bulletin Board System)在不同进化阶段的称谓\n\n\n\n# 怎么做自己的地方门户?\n- 分类要多，要全，要热门\n- 应该有社区功能\n- 应该有社交功能\n\n\n# 门户网站用户愿意在上面互动吗？\n先不说愿意不愿意，如果不互动，哪来的信息？？？？\n所以，必须得有，比如头条就有用户发布信息的地方\n\n\n# 门户网站倒地是什么东西？？？\n门户就是能放眼望世界的地方，转意为全方位多面信息汇聚的地方\n\n\n\n\n\n\n\n","categories":["SEO"]},{"title":"外链","url":"/2018/05/19/SEO/外链/","content":"\n# 外链\n\n总的来说，外链越多越好，说白了，别人的网页上有你的网站链接越多越好，这样搜索引擎任务你这个网站就越受别人欢迎","categories":["SEO"]},{"title":"关键词","url":"/2018/05/19/SEO/关键词/","content":"\n# 关键词\n\n用户想要进入你的站点，绝大多数是通过搜索引擎搜素进来的,所以，关键词就很重要\n\n# 怎么知道什么关键词好呢\n\n- [百度指数](http://index.baidu.com)\n- [谷歌趋势](https://trends.google.com/trends/)","categories":["SEO"]},{"title":"总结","url":"/2018/05/19/SEO/总结/","content":"\n# 总结\n\nSEO本质就是让搜索引擎准确的搜索到你，其实就这么简单\n关键词，外链，等等等，都是围绕这一点来的\n\n# 但是\n如果一个站点做的就是为了SEO而作，那么还有意义吗，不是，本质上还是自己的站点用户觉得有意义，才是重点，重点是自己，不是SEO","categories":["SEO"]},{"title":"SPA怎么SEO","url":"/2018/05/19/SEO/SPA怎么SEO/","content":"\n# SPA怎么SEO?\n很麻烦，比如使用了vue的页面，百度无法抓取，只能使用nuxt.js来ssr(服务端渲染);","categories":["SEO"]},{"title":"SEO基本术语","url":"/2018/05/19/SEO/SEO基本术语/","content":"\n# 长尾关键词\n网站上非目标关键词但也可以带来搜索流量的关键词，称为长尾关键词。\n- 比较长，往往是2-3个词组成，甚至是短语。\n- 存在于内容页面，除了内容页的标题，还存在于内容中。\n- 搜索量非常少，并且不稳定。\n- 长尾关键词带来的客户，转化为网站产品客户的概率比目标关键词低很多。\n- 存在大量长尾关键词的大中型网站，其带来的总流量非常大。\n\n# Backlinks-导入链接 反向链接\nBacklinks=Inbound Links 中文叫：导入链接、外部链接\n导入链接是搜索引擎特别是google衡量一个网站受欢迎程度的重要因素之一\n\n\n# Sitemap-网站地图\n\n- 让搜索引擎全面收录你的站点网页地址\n- 让搜索引擎了解你的站点网页地址的权重分布\n- 让搜索引擎了解你的站点内容更新情况\n\n# Sandbox-沙盒效应\n\n新站在刚上线的几个月内在Google很难有好的排名，甚至没有排名。这个现象我们称为：Sandbox-沙盒效应\n\nSandbox-沙盒效应。\n\n一个新的网站，即使已经做了很好的SEO优化：丰富的相关内容，大量的高质量外部链接，网站URL搜索引擎友好，网站结构用户体验友好等。但在刚上线的几个月内，在Google几乎找不到好的排名。\n\nGoogle的Sandbox-沙盒效应一般会持续6个月，这6个月内新站应该不断完善各方面SEO，沙盒效应过后，一般会有不错的排名。\n\n百度对新站也有一个“建立信任期”，一般是2个月。这两个月内，过多得修改网站结构，修改文章标题，会造成百度对站点信任度的降低\n\n\n# 死链接\n死链接指原来正常，后来失效的链接。死链接发送请求时，服务器返回404错误页面\n\n# 收录\n是否被搜索引擎收录\n\n# 权重\n=== PR\n# PR\nPR值全称为PageRank(网页级别)。\n\n它是Google用于用来标识网页的等级/重要性的一种方法。在揉合了诸如Title标识和Keywords标识等所有其它因素之后，Google通过PageRank来调整结果，使那些更具“等级/重要性”的网页在搜索结果中另网站排名获得提升，从而提高搜索结果的相关性和质量\n\n# Cloaking-障眼法\n\n指对某一个网页制作了两个版本，让搜索引擎和浏览者分别看到不同的网页内容（采用识别访问者身份的技术）。搜索引擎抓取这个网页时，获得的是纯粹为了优化某些关键词而组织的内容，而网页浏览者看到的是另一个截然不同的内容。\n\nCloaking-障眼法是典型的SEO作弊，搜索引擎一旦识别就会对网站进行严厉惩罚。","categories":["SEO"]},{"title":"世界网站排行","url":"/2018/05/15/SEO/世界网站排行/","content":"\n# 世界网站排行\n\n## 搜索引擎\n- google.com\n- baidu.com\n- bing.com\n- soso.com\n- \n- \n- \n## 社交媒体\n- facebook.com \n- twitter.com\n- weibo.com\n- instagram.com\n- blogspot.com\n- \n## 门户网站\n- yahoo.com\n- qq.com\n- \n- \n- \n- \n## 购物\n- taobao.com \n- ebay.com\n- \n- \n- \n- \n## 导航\n- msn.com\n- hao123.com\n- \n- \n- \n- \n- \n## 新闻\n- sina.com.cn\n- \n- \n- \n- \n- \n## 其他\n- wikipedia.org\n- wordpress.com\n- \n- \n- \n- \n- \n- \n\n# 参考链接\n[http://alexa.chinaz.com/Global/index.html](http://alexa.chinaz.com/Global/index.html)\n\n","categories":["SEO"]},{"title":"biji","url":"/2018/04/12/VUE/biji/","content":"\n# v-bind:class 指令也可以与普通的 class 属性共存。\n\n```\n<div class=\"static\"\n     v-bind:class=\"{ active: isActive, 'text-danger': hasError }\">\n</div>\n```\n\n# 计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter\n\n```\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n```\n\n现在再运行 vm.fullName = 'John Doe' 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。\n\n# watch && computed 对比\n\n* watch 更通用，可以执行异步操作等，范围更大\n* computed:更简单，适用于绝大部分场景，\n\n# 用 key 管理可复用的元素\n\n[用 key 管理可复用的元素](https://cn.vuejs.org/v2/guide/conditional.html#%E7%94%A8-key-%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%85%83%E7%B4%A0)\n\n# 可以用 of 替代 in 作为分隔符\n\nv-for=\"item of items\"\nv-for=\"item in items\"\n你也可以用 of 替代 in 作为分隔符，因为它是最接近 JavaScript 迭代器的语法：\n\n```\n<button v-on:click=\"say('hi')\">Say hi</button>//\n<button v-on:click=\"greet\">Greet</button>\n```\n\n函数名或者让函数执行，都可以\n\n如果你想把一个对象的所有属性作为 prop 进行传递，可以使用不带任何参数的 v-bind (即用 v-bind 而不是 v-bind:prop-name)。例如，已知一个 todo 对象：\n\n```\n<todo-item v-bind=\"todo\"></todo-item>\n===\n<todo-item\n  v-bind:text=\"todo.text\"\n  v-bind:is-complete=\"todo.isComplete\"\n></todo-item>\n```\n\n```\ncomputed: {\n    myList: {\n        get() {\n            return this.$store.state.myList\n        },\n        set(value) {\n            this.$store.commit('updateList', value)\n        }\n    }\n}\n```\n","categories":["VUE"]},{"title":"CORS","url":"/2018/04/06/JAVASCRIPT/CORS/","content":"\n\n# 由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域\n","categories":["JAVASCRIPT"]},{"title":"mongoose","url":"/2018/04/03/MONGODB/mongoose/","content":"# mongoose\n\n\n# model 方法\n- find([obj])\nobj:搜索条件","categories":["MONGODB"]},{"title":"get&set","url":"/2018/04/03/JAVASCRIPT/get&set/","content":"\n```\nvar oo = {\n    name : '贤心',\n    get sex(){\n        return 'man';\n    }\n};\noo.sex = 'woman';//无效\nconsole.log(oo.sex); //结果依然是man\n```\n通过这种方式，就可以实现只读属性\n","categories":["JAVASCRIPT"]},{"title":"egg","url":"/2018/04/02/NODEJS/egg/","content":"\n# egg\n基于koa的框架\n\n# 配置\n\n\n\n# 插件的开关\nconfig/plugin.js中配置\n```\nexports.nunjucks = {\n  enable: true,\n  package: 'egg-view-nunjucks'\n};\n```\n# 插件的配置\n```\n// config/config.default.js\nexports.keys = <此处改为你自己的 Cookie 安全字符串>;\n// 添加 view 配置\nexports.view = {\n  defaultViewEngine: 'nunjucks',\n  mapping: {\n    '.tpl': 'nunjucks',\n  },\n};\n```\n# 自定义启动脚本 app.js\n\n```\n// app.js\nmodule.exports = app => {\n  app.beforeStart(async () => {\n    // 应用会等待这个函数执行完成才启动\n    app.cities = await app.curl('http://example.com/city.json', {\n      method: 'GET',\n      dataType: 'json',\n    });\n\n    // 也可以通过以下方式来调用 Service\n    // const ctx = app.createAnonymousContext();\n    // app.cities = await ctx.service.cities.load();\n  });\n};\n```\n\n# 内置对象\nthis.app=this.ctx.app\n\n\n# 定时任务\n\n\n# 应用内获取运行环境\n\n# 配置\n\n```\nconfig\n|- config.default.js\n|- config.test.js\n|- config.prod.js\n|- config.unittest.js\n`- config.local.js\n\n```\n\nconfig.default.js 为默认的配置文件，所有环境都会加载这个配置文件，一般也会作为开发环境的默认配置文件\n\n\nprod 环境会加载 config.prod.js 和 config.default.js 文件，config.prod.js 会覆盖 config.default.js 的同名配置\n\n\n优先级（应用 > 框架 > 插件）\n\n\n# 中间件\n```\n//config.default.js\nmodule.exports = {\n  // 配置需要的中间件，数组顺序即为中间件的加载顺序\n  middleware: [ 'gzip' ],\n\n  // 配置 gzip 中间件的配置\n  gzip: {\n    threshold: 1024, // 小于 1k 的响应体不压缩\n  },\n};\n```\n\n\n\n\n一个常见的错误是把 ctx.request.body 和 ctx.body 混淆，后者其实是 ctx.response.body 的简写。\n\n\n# ajax\n如果在同一个域名下面，所有的http请求都是带有cookie的，包括ajax请求，不是a页面有cookie，b页面就没有了，一旦某个请求让\n服务器设置了一个cookie，那么接下来，所有的请求都会带有这个新设置的cookie\n\n\n# 中间件、插件、应用的关系\n\n# 内置插件\n- onerror 统一异常处理\n- Session Session 实现\n- i18n 多语言\n- watcher 文件和文件夹监控\n- multipart 文件流式上传\n- security 安全\n- development 开发环境配置\n- logrotator 日志切分\n- schedule 定时任务\n- static 静态服务器\nonp jsonp 支持\n- view 模板引擎\n\n\n\n# npm install --production\n只安装 dependencies 的依赖","categories":["NODEJS"]},{"title":"mongodb","url":"/2018/04/01/MONGODB/mongodb/","content":"# windows 安装\nmongo compass不要安装，我本地测试，一直会卡在这个地方，去掉勾选就很快安装完成\n\n将mongo 的bin目录添加到path中去\n\nmongodb的推荐目录\n```\n-dbpath\n--config:配置目录\n---mongod.conf:mongodb的配置文件\n--data:数据库文件\n--log:日志目录\n```\n\nmongod.conf\nmongod --help 中的选项，可以放到改文件中\n```\ndbpath=db\nauth=true\n```\nmongod --config ./config/mongod.conf\n\n\n\n# 概念\ndb\ncollection:相当于table\n\n# _id:主键，自动生成\n\n# 常用命令\n```\n//数据库操作\nshow dbs;//查看所有数据库\ndb;//查看当前数据库\nuse db;//切换数据库，如果数据库不存在，会自动创建\ndb.dropDatabase();//删除当前数据库\n\n//collection 操作\nshow collections;//查看当前数据库的所有collections\nshow tables;//查看当前数据库的所有collections === show collections\ndb.collection_name.remove();删除当前数据库的collection_name\ndb.collection_name.insert();在当前数据库的collection_name插入\ndb.collection_name.find([opt]);查找,默认显示所有符合条件的数据\ndb.collection_name.findOne();\ndb.collection_name.save();//如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据\ndb.collection_name.update();\ndb.collection_name.updateOne([opt]);\ndb.collection_name.delete([opt]);\ndb.collection_name.deleteOne([opt]);\ndb.collection_name.pretty();//结构化展示\ndb.collection_name.count([opt]);//计算数量\ndb.collection_name.skip(num);//结果中跳过前num条，默认是0\ndb.collection_name.limit(num);//从结果中只取出num条\ndb.collection_name.sort(opt);//opt={name:1,age:-1},1：asc,-1:desc\n\n```\n\n# db.collection.find([opt])\n\n大于，小于，等于\n```\ndb.mycollection1.find( {num1:3} ); //等于\ndb.mycollection1.find( {num1:{$gt:3}} ); //大于\ndb.mycollection1.find( {num1:{$lt:3}} ); \ndb.mycollection1.find( {num1:{$gte:3}} ); \ndb.mycollection1.find( {num1:{$lte:3}} ); \ndb.mycollection1.find( {num1:{$ne:3}} ); \ndb.mycollection1.find( {num1:{$in:arr}} ); \n```\n\n## AND 条件\n```\ndb.col.find({key1:value1, key2:value2});// where(key1=val1 and key2=val2)\n```\n## OR 条件\n```\ndb.col.find(\n   {\n      $or: [\n         {key1: value1}, {key2:value2}\n      ]\n   }\n)\n```\n\n## AND 和 OR 联合使用\n\n```\ndb.col.find(\n   {\n      $or: [\n         {key1: value1}, {key2:value2}\n      ],\n      {key1:value1, key2:value2}\n   }\n)\n```\n\n\n# collection删除指定文件\ndb.collection.remove()\n\n\n\n\n\n#  索引\ndb.collection.ensureIndex(indexes,[opt]):创建索引\n```\ndb.collection.ensureIndex({age:1});//age asc的索引\ndb.collection.ensureIndex({age:1,name:-2});//age asc,name desc的复合索引\ndb.collection.ensureIndex({age:1,name:-2},{unique:true});//索引唯一\n```\n\n# 聚合\nMongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。\n```\ndb.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)\n```\n\n```\n\ndb.mycol.aggregate([{$group : {_id : \"$group_field\", field2 : {$sum : 1}}}]);//根据group_field字段分组，计算field2的sum\n```\n- $sum\n- $avg  \n- $min\n- $max\n- $max\n\n\n# 安全\nmongod --auth:默认是false,也就是说默认是不需要密码登录的\n所以，流程得这样走\n先关掉auth，然后登录进入，找到对应的db，添加一个用户，指定权限候，开启auth，然后重启mongod，然后重新登录\n\n创建用户\n创建的用户是跟着db走的\n```\ndb.createUser({\n    user:'xxx',\n    pwd:'xxx',\n    roles:[\n        {role:'read',db:'test'},\n        {role:'readWrite',db:'test'},\n        {role:'dbAdmin',db:'test'},\n    ]\n})\n```\n\nrole:系统内置角色，很多\n- read\n- readWrite\n- dbAdmin\n\n自己测试发现一个小问题,如果只给用户dbAdmin的话，我是无法查看数据的,必须还要给readWrite才可以\n\n\n\n\n\n\n\n\n# 参考链接\n- [https://blog.csdn.net/dbabruce/article/details/50963956](https://blog.csdn.net/dbabruce/article/details/50963956)\n- [http://www.runoob.com/mongodb/mongodb-tutorial.html](http://www.runoob.com/mongodb/mongodb-tutorial.html)\n- [https://blog.csdn.net/dbabruce/article/details/50963956](https://blog.csdn.net/dbabruce/article/details/50963956)\n","categories":["MONGODB"]},{"title":"COMMONJS,AMD,CMD","url":"/2018/03/29/NODEJS/COMMONJS,AMD,CMD/","content":"\n# COMMONJS\n适用于服务器端，同步加载\n格式:\n```\nexports.a=111;\nexports.b=222\n////or\nmodule.exports={\n    a:111,\n    b:222\n}\n\n```\n# AMD\n适用于浏览器端，异步加载\n\n格式:\n```\n//define(id?,dependcies?,factory);\ndefine('mod1',['dep1','dep2'],function(dep1,dep2){\n    var a=111;\n    return a;\n})\n//or\ndefine(function(dep1,dep2){\n    var a=111;\n    return a;\n})\n\n```\n# CMD\n\n\n适用于浏览器端，异步加载\n\n格式:\n```\n//define(factory);\ndefine(function(require,exports,module){\n    var a=111;\n    return a;\n})\n\n\n```\n\n# 兼容写法\n\n```\n\n;(function(name,definition){\n  let is_amd;\n  //判断是否是AMD OR CMD\n  if(typeof define !== undefined){\n    is_amd=true;\n  }else{\n    is_amd=false;\n  }\n  //判断是否是COMMONJS\n  let is_commonjs;\n  if(typeof exports !== undefined && module.exports !== undefined){\n    is_commonjs=true;\n  }else{\n    is_commonjs=false;\n  }\n\n  //判断\n\n  if(is_amd){\n    define(definition);\n  }else if(is_commonjs){\n    module.exports=definition();\n  }else{\n    this[name]=definition;//window环境\n  }\n\n\n})('mod1',function(){\n  var a=111;\n  return a;\n})\n\n```\n\n","categories":["NODEJS"]},{"title":"clild_process","url":"/2018/03/28/NODEJS/clild_process/","content":"\n# clild_process\n\n\n\n#常见方法\n- exec()\n- execFile()\n- spawn()\n- fork()\n- send()","categories":["NODEJS"]},{"title":"cluster","url":"/2018/03/28/NODEJS/cluster/","content":"\nNode.js默认单进程运行，对于多核CPU的计算机来说，这样做效率很低，因为只有一个核在运行，其他核都在闲置。cluster模块就是为了解决这个问题而提出的。\n\ncluster模块允许设立一个主进程和若干个worker进程，由主进程监控和协调worker进程的运行。worker之间采用进程建通信交换消息，cluster模块内置一个负载均衡器，采用Round-robin算法协调各个worker进程之间的负载。运行时，所有新建立的链接都由主进程完成，然后主进程再把TCP连接分配给指定的worker进程。","categories":["NODEJS"]},{"title":"process","url":"/2018/03/26/NODEJS/process/","categories":["NODEJS"]},{"title":"BDD&TDD","url":"/2018/03/25/NODEJS/BDD&TDD/","content":"\n\n# BDD\nBehavior Driven Development，行为驱动开发是一种敏捷软件开发的技术，它鼓励软件项目中的开发者、QA和非技术人员或商业参与者之间的协作。\n\n# TDD\nTEST Driven Development\n\n测试驱动开发是敏捷开发中的一项核心实践和技术，也是一种设计方法论。TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。TDD的基本思路就是通过测试来推动整个开发的进行，但测试驱动开发并不只是单纯的测试工作，而是把需求分析，设计，质量控制量化的过程。TDD首先考虑使用需求（对象、功能、过程、接口等），主要是编写测试用例框架对功能的过程和接口进行设计，而测试框架可以持续进行验证。 ","categories":["NODEJS"]},{"title":"exports和module.exports的区别","url":"/2018/03/25/NODEJS/exports和module.exports的区别/","content":"\n\n# 但是你不可以直接对exports赋值\n```\nexports = {\n    hello: hello,\n    greet: greet\n};//错误的\n```\n\n```\nexports.hello = hello;\nexports.greet = greet;\n//正确的\n```\n\n给exports赋值是无效的，因为赋值后，module.exports仍然是空对象{}。\n\n[参考链接](https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434502419592fd80bbb0613a42118ccab9435af408fd000)\n","categories":["NODEJS"]},{"title":"深入浅出Node.js","url":"/2018/03/24/BOOK/深入浅出Node.js/","content":"\n\n\n# 全局安装\n全局默认不是将一个模块安装为全局包的意思，并不是可以在任何地方通过require()来引用到它，\n-g 是将一个安装包安装为全局可用的可执行命令，它将根据package.json中的bin字段配置，将实际的脚本连接到与node可执行目录文件相同的路径下\n","categories":["BOOK"]},{"title":"7-days-nodejs","url":"/2018/03/24/BOOK/7-days-nodejs/","content":"\n# [http://nqdeng.github.io/7-days-nodejs](http://nqdeng.github.io/7-days-nodejs)\n\n# 主模块\n\n通过命令行参数传递给 NodeJS 以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其它模块完成工作。例如通过以下命令启动程序时，main.js 就是主模块。\n\n```\n node main.js\n```\n\nNodeJS 使用 CMD 模块系统，主模块作为程序入口点，所有模块在执行过程中只初始化一次。\n\n# NODE_PATH 环境变量\n\n与 PATH 环境变量类似，NodeJS 允许通过 NODE_PATH 环境变量来指定额外的模块搜索路径。NODE_PATH 环境变量中包含一到多个目录路径，路径之间在 Linux 下使用:分隔，在 Windows 下使用;分隔\n\n# index.js\n\n# package.json\n\nmain:指定模块入口文件\n\n# 命令行程序\n\n## linux 环境中\n简单说就是把一个 js 文件当作一行命令来执行\nlinux 系统很简单，只要是文件就可以当作命令来执行\n\n## windows 环境中\n\nwindows 就不一样了，很麻烦，需要使用.cmd文件\n\n```\n#! /usr/bin/env node\nconsole.log(1111);\n```\n\n## windows 中怎么办?使用 git bash\n\n# 工程目录\n\n```\n- /home/user/workspace/node-echo/   # 工程目录\n    - bin/                          # 存放命令行相关代码\n        node-echo\n    + doc/                          # 存放文档\n    - lib/                          # 存放API相关代码\n        echo.js\n    - node_modules/                 # 存放三方包\n        + argv/\n    + tests/                        # 存放测试用例\n    package.json                    # 元数据文件\n    README.md                       # 说明文件\n```\n\n\n# npm\n\n参数中的-g表示全局安装，因此node-echo会默认安装到以下位置，并且NPM会自动创建好Linux系统下需要的软链文件或Windows系统下需要的.cmd文件\n\n# 版本号\n\n\n# NPM常用命令\n\nnpm help:查看所有命令\n\n\n使用npm help <command>可查看某条命令的详细帮助，例如npm help install。\n\n在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。\n\n使用npm update <package>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。\n\n使用npm update <package> -g可以把全局安装的对应命令行程序更新至最新版。\n\n使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。\n\n使用npm unpublish <package>@<version>可以撤销发布自己发布过的某个版本代码。\n\n\n\n# 文件操作\n\n\n\n","categories":["BOOK"]},{"title":"webpack","url":"/2018/03/19/TOOLS/webpack/","content":"\n\n\n# 什么是webpack？\n\n就是一个模块打包机\n\n\n\n\n\n# 优点和缺点是什么？\n\n## 优点\n- 支持模块化，yo webapp 不支持js模块化的，这个就是一个很大的问题\n- 配置简单，相比于gulp，配置更加简单，内置的webpack-dev-serve非常简单好用\n\n## 缺点\n- 上手太难，引入一张图片都很麻烦，\n\n# 核心概念\n\n\n- Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。\n- Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。\n- Chunk：代码块，一个 Chunk 由多个模块组合而成，**用于代码合并与分割**。\n- Loader：模块转换器，用于把模块原内容按照需求转换成新内容。\n- Plugin：扩展插件，在 Webpack 构建流程中的**特定时机注入扩展逻辑**来改变构建结果或做你想要的事情。\n- Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。\n\n\n# entry\n# Output\n# Module\n# Resolve\n# Plugins\n# DevServer\n# others\n# others\n\n\n## webpack基础配置 , webpack.config.js\n\n```\nmodule.exports={\n    entry:'./src/main.js',\n    output:{\n        filename:'boundle.js',\n        path:__dirname+'/dist'\n    },\n    module:{\n        rules:[\n            {\n                test:/\\.css$/,\n                use:[\n                    'style-loader','css-loader'\n                ]\n            },\n            {\n                test:/\\.(jpg|jepg|png|gif)$/,\n                use:[\n                    'file-loader'\n                ]\n            },\n        ]\n    }\n}\n```\n\n# 常见loader\n- CSS-loader\n- style-loader\n- sass-loader\n- file-loader\n- \n\n\n# 常见plugin\n- HTML-webpack-plugin:使用模板来构建页面\n- clean-webpack-plugin:删除指定目录\n- uglifyjs-webpack-plugin:压缩js\n- CommonsChunkPlugin :防止重复\n- \n- \n\n\n# 自动刷新\n- webpack's Watch Mode (webpack --watch)\n- webpack-dev-server(webpack-dev-server)\n- webpack-dev-middleware\n\n\n\n# TREE SHAKING\n为了学会使用 tree shaking，你必须\n- 使用 ES2015 模块语法（即 import 和 export）。\n- 引入一个能够删除未引用代码(dead code)的压缩工具(minifier)（例如 UglifyJSPlugin）。\n\n\n\n# 问题\n- 如何生成多个页面，比如index.html,list.html，其中还有通用部分\n\n\n\n\n# 代码分离\n- 代码分离到不同的 bundle 中,然后可以按需加载或并行加载这些文件\n- \n- \n- \n\n# loader 传参的两种形式\n```\nmodule: {\n    rules: [\n      {\n        // 用正则去匹配要用该 loader 转换的 CSS 文件\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader?minimize'],\n      }\n    ]\n  }\n\n```\n\n```\nuse: [\n  'style-loader', \n  {\n    loader:'css-loader',\n    options:{\n      minimize:true,\n    }\n  }\n]\n\n```\n\n# use loaders loader 用哪个？\n\n\n\n# .babelrc\n- plugins:告诉 Babel 要使用哪些插件，插件可以控制如何转换代码。\n- presets:告诉 Babel 要转换的源码使用了哪些新的语法特性,一个 Presets 对一组新语法特性提供支持，多个 Presets 可以叠加。 Presets 其实是一组 Plugins 的集合，每一个 Plugin 完成一个新语法的转换工作\n\n\n# 修改模板，页面自动刷新，如何做到？？？？？\n默认在devServer中开启hot:true，可以做到js修改，会修改，但是模板修改不会自动刷新\n那么如何做到呢？\n在webpack中，实现自动刷新有两种方法，一种是webpack自带的watch功能，一种就是webpack-dev-server中的hot功能\nhot功能：js修改，可以实现页面无刷新而修改js，但是tempate修改不会\nwatch功能：js修改，页面会刷新，template修改，也会刷新页面\n所以，总结\n- 页面的构建，几乎都写在template中的话，使用watch\n- 页面的构建，几乎都写在main.js中的话，使用hot\n\n\n# output.publicPath 配置好，devserver就会自动跳转到一个类似于public的目录页面，为什么？\n\n\n# output.publicPath:'asdf'\noutpath输出路径是 ouput.publicPath+path+filename\noutput.publicPath默认是'',\n仅此而已，不要和devserver混淆到一起\n改配置仅仅修改了bundle的输出路径，个人觉得最好只在product中设置\n\n```\n<script type=\"text/javascript\" src=\"asdf/scripts/main--f2a22f432c0ed250bb55.js\"></script>\n```\n所以该配置个人觉得一般仅仅是在product中才会设置，dev中千万不要设置，否则找不到目录\n\n## template 的图片，是按照哪个相对目录来的？\ndevServer.contentBase来的，该属性默认为该项目目录 \n## css中的图片，是按照哪个目录来的？\n引入该css文件的js文件来的\n\n# 如何使用webpac制作一个通用的模块呢？？？？\nlibary,libarTarget\n\n\n# 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的\n\n\n\n\n# context: __dirname, // string（绝对路径！）\n  // webpack 的主目录\n  // entry 和 module.rules.loader 选项\n  // 相对于此目录解析\n\n# mock数据\n\n```\ndevServer: {\n    hot: true,\n    open: true,\n    // contentBase: path.resolve(__dirname, 'app/images'),\n    before:function(app){\n        app.get('/test/',function(req,res){\n            res.end('xxxxxxx');\n        })\n    },\n},\n```\n\n# devServer.contentBase\n\n告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要。devServer.publicPath 将用于确定应该从哪里提供 bundle，并且此选项优先。\n\n默认情况下，将使用**当前工作目录**作为提供内容的目录，但是你可以修改为其他目录：\n\ncontentBase: path.join(__dirname, \"public\")\n注意，推荐使用绝对路径。\n\n## 当前工作目录指的是这个项目所在的目录，不设置的话，默认是可以访问这个项目中所有的资源的\n\n# devServer.overlay:全屏显示错误\n\n\n# devServer.proxy\n```\nproxy: {\n    \"/api\": {\n        target: \"http://www.test.com/news.php\",\n        changeOrigin: true\n    }\n}\n```\n必须添加`changeOrigin`属性\n\n\n#devServer.publicPath:这个目录甚至可以是瞎写的\n此路径下的打包文件可在浏览器中访问。\n\n假设服务器运行在 http://localhost:8080 并且 output.filename 被设置为 bundle.js。默认 publicPath 是 \"/\"，所以你的包(bundle)可以通过 http://localhost:8080/bundle.js 访问。\n\n\n\n# 笔记\n\nwebpack 不会更改代码中除 import 和 export 语句以外的部分","categories":["TOOLS"]},{"title":"yarn","url":"/2018/03/19/TOOLS/yarn/","content":"\n#yarn的优势\n- 快速，本地缓存\n- 锁定版本号\n\n# 常用命令\n- yarn init(npm init)\n- yarn add (npm install)\n- yarn add webpack --dev (npm install webpack --save-dev)\n- yarn remove webpack  (npm uninstall webpack --save-dev):yarn remove的时候，不需要指定--dev，只要存在，就移出，无论在哪个里面\n- yarn upgrade jquery (npm update jquery);\n- yarn global add/remove/upgrade (npm -g install/update/uninstall);\n- yarn install(npm install)\n\n\n\n\n# 参考链接\n- https://segmentfault.com/a/1190000007189426","categories":["TOOLS"]},{"title":"webpack-tree shaking","url":"/2018/03/19/TOOLS/webpack-tree shaking/","content":"\n\n# TREE SHAKING  \n官网上说的两点\n- export inport使用\n- 代码压缩工具,uglifyjs\n\n但是使用有局限\n# 局限1\n```\nexport function square(x) {\n    return x * x;\n}\n\nexport function cube(x) {\n    return x * x * x;\n}\n\n```\n\n这样导出，可以实现shaking\n\n假如这样呢\n\n```\nexport default {\n    square:function(x){\n        return x * x;\n    },\n    square:function(x){\n        return x * x;\n    },\n}\n```\n不会\n# 局限2\n```\n{\n    \"presets\": [\n        [\n            \"env\", {\n                \"loose\": true,\n                \"modules\": false\n            }\n        ]\n    ]\n}\n\n\n```\nbabel需要这样设置，才会生效\n","categories":["TOOLS"]},{"title":"mockjs","url":"/2018/03/19/TOOLS/mockjs/","content":"\n\n# MOCKJS:生成模拟数据\n原理：\nMock.js 通过覆盖和模拟原生 XMLHttpRequest 的行为来拦截 Ajax 请求\n\n所以，只要是xhr就可以拦截，但是jsonp就不可以了，jsonp的原理不是xhr\n\n基本规则\n```\n'name|rule': value\n```\n# string，number,float,object,array的模拟\n\n```\nMock.mock({\n    \"username|3-5\":'a',\n    \"age|20-29\":1,//后面的1没有意义\n    \"money|100-200.2\":1,//两位数的小数\n    \"info|1-2\":{a:1,b:2,c:3,d:4},\n    \"hobbies|1-2\":['swim','reading','singing'],\n})\n```\n\n\n\n\n# 参考链接\n- http://mockjs.com/examples.html","categories":["TOOLS"]},{"title":"webpack alias","url":"/2018/03/19/TOOLS/webpack alias/","content":"\n\n# alias 设置别名\n创建 import 或 require 的别名，来确保模块引入变得更简单\n\n不设置别名\n```\nimport mod1 from './app/mod1.js'\n```\n\n\n```\nresolve:{\n    alias:{\n        mod1:'./app/mod1.js'\n    }\n}\n```\n```\nimport mod1 from 'mod1'\n```","categories":["TOOLS"]},{"title":"webpack import()","url":"/2018/03/19/TOOLS/webpack import()/","content":"\n\n# import()\n异步导入\n需要使用babel的一个插件才可以使用\n```\nyarn add  --dev babel-plugin-syntax-dynamic-import\n\n```\n.babelrc\n```\n{\n    \"presets\": [\n        [\n            \"env\", {\n                \"loose\": true,\n                \"modules\": false\n            }\n        ]\n    ],\n    \"plugins\": [\"syntax-dynamic-import\"]\n}\n\n\n```\n","categories":["TOOLS"]},{"title":"webpack 使用cdn","url":"/2018/03/19/TOOLS/webpack 使用cdn/","content":"\n# 如何使用cnd\n```\nexternals:{\n    // require(\"zepto\") is external and available\n  //  on the global var Zepto\n  'zepto': 'Zepto'\n}\n```\n设置这个东西的话，就是说打包的时候，不会将zepto打包进去，这样设置的话，外部一定要引入zepto，否则将没有Zepto可以使用，因为不会被打包进去\n\n# 容易犯的错误\n1：我在模板中引入lodash 的cdn，但是我没写externals，然后main.js中正常引入lodash，发现没报错，那么会怎么样???\n打包的时候，会将lodash打包进去，这样的话，就有两个lodash了\n\nmain.js\n```\nimport _ from 'lodash';\n\ndocument.title=_.join([1,2,3],'|');\n\n```\n\nindex.html\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n    <script src=\"https://cdn.bootcss.com/lodash.js/4.17.4/lodash.min.js\"></script>\n</head>\n<body>\n    \n</body>\n</html>\n```\n\n# 竟然报错了\n\n```\nexternals: {\n        \"lodash\": 'lodash'\n}\n```\n\n这个地方一定要注意的就是,key是包名称，val的是全局变量\n\n```\n    externals: {\n        \"lodash\": '_'\n    }\n```\n\n\n\n\n\n\n","categories":["TOOLS"]},{"title":"未解决问题","url":"/2018/03/19/QUESTION/未解决问题/","content":"\n# import 'xxx'\n这样就可以实现不用起名字来引入一个包了\n\n# umd是什么？？？？\n\n\ngulp-live-server:gulp 服务器\ngulp-live-load:热更新\nrequire-dir\n\n\n#Array.from() es6中提供的将非数组的数据结构，转换成数组解构\n\n# es6如何多重继承\n\n# 设计稿高度标注为80px，实际写的时候，就应该标注为40px;???为什么？？？\n\n# 移动端1px的问题，移动端都是50%的，那么设计稿上的1px线条，怎么在手机上显示呢\n假如写成1px的话，pc上看是没有问题的，但是真正的手机上会显示2px\n使用伪类，高度设置为1px，然后使用transform:scaleY(0.5)来实现1px\n\n# 如何在真正手机上看到真实的开发过程中的页面呢\n同一个局域网中，使用ipconfig/ifconfig来查看自己本机的局域网中的ip地址，然后只要在同一个局域网中的电脑，就可以查看了\n\n#vertical-align\n# 手机上字体最小也是12px吗\n\n#font-size:0有什么用\ndisplay为inline和inline-block的时候，当你代码换行后，会在网页上产生一个空格，避免方法可以不换行，只不过这种方法很不好，所以一般都是font-size设为0\n所以这就是一个hack技巧，设置为零，换行的时候，就没有间隙了\n#css如何实现模糊效果\nfilter：滤镜\n\n\n# 如果JSON.parse()出错了，怎么办？\n\n\n# 怎么生成随机的汉字\n```\nString.fromCodePoint(Math.round(Math.random() * 20901) + 19968)\n```","categories":["QUESTION"]},{"title":"投资小题","url":"/2018/03/19/QUESTION/投资小题/","content":"\n每年投资1万，年收益是110%,每年都投资，十年后连本带利多少钱\n\n","categories":["QUESTION"]},{"title":"如何找到数组最小值","url":"/2018/03/19/QUESTION/找到数组最小值/","content":"\n\nGiven an array of integers, remove the smallest value. Do not mutate the original array/list. If there are multiple elements with the same value, remove the one with a lower index. If you get an empty array/list, return an empty array/list.\n\nDon't change the order of the elements that are left.\n\nExamples\n\n```\nremoveSmallest([1,2,3,4,5]) = [2,3,4,5]\nremoveSmallest([5,3,2,1,4]) = [5,3,2,4]\nremoveSmallest([2,2,1,2,1]) = [2,2,2,1]\n```\n\n","categories":["QUESTION"]},{"title":"如何生成二维码","url":"/2018/03/19/QUESTION/如何生成二维码/","content":"\n\n","categories":["QUESTION"]},{"title":"如何打开一个新窗口，可以指定大小，位置，内容","url":"/2018/03/19/QUESTION/如何打开一个新窗口，可以指定大小，位置，内容/","content":"\n```\nwindow.open('http://www.baidu.com','asdf','width=200,height=100,left=300')\n```\n# 参考链接\nhttp://www.w3school.com.cn/jsref/met_win_open.asp\n\n\n","categories":["QUESTION"]},{"title":"一个对象中，key可以用变量表示吗","url":"/2018/03/19/QUESTION/一个对象中，key可以用变量表示吗/","content":"\n\n\n```\nvar key1='qqq';\nvar obj={\n    name:'asdf',\n    [key1]:333\n}\n```\n\n可以，必须使用[]括起来，小括号，大括号都不行","categories":["QUESTION"]},{"title":"select 如何自定义样式","url":"/2018/03/19/QUESTION/select 如何自定义样式/","content":"\n","categories":["QUESTION"]},{"title":"一个正方形，先变长，再变宽，怎么实现？？？","url":"/2018/03/19/QUESTION/一个正方形，先变长，再变宽/","content":"\n一个正方形，先变长，再变宽\n\n```\n\n.box{\n  width: 100px;\n  height: 100px;\n  background-color: #aaa;\n  &:hover{\n    width: 300px;\n    height: 300px;\n    transition:1s width,1s 1s height;\n  }\n}\n\n```\n\n","categories":["QUESTION"]},{"title":"如何实现打字效果","url":"/2018/03/19/QUESTION/如何实现打字效果/","content":"\n\nvar title=document.getElementById('title');\nvar str='THIS IS A TEST';\nvar arr=str.split('');\nvar t=setInterval(function(ev){\n    var res=arr.shift() ;\n    if( res  ){\n        title.innerHTML+=res;\n    }else{\n        clearInterval(t);\n    }\n},1000)\n\n\n```\n\n","categories":["QUESTION"]},{"title":"如何完整的拷贝一个线上的网页","url":"/2018/03/19/QUESTION/如何完整的拷贝一个线上的网页/","content":"\n","categories":["QUESTION"]},{"title":"checkbox radio样式如何自定义","url":"/2018/03/19/QUESTION/checkbox radio样式如何自定义/","content":"\n\n\n","categories":["QUESTION"]},{"title":"如何实现数组的复制？？？？","url":"/2018/03/19/QUESTION/JS如何实现数组的复制/","content":"\n如何实现数组的复制？？？？\n\n```\nvar arr=[1,2,3];\nvar new_arr=arr.concat();\n```","categories":["QUESTION"]},{"title":"星期六","url":"/2018/03/19/LIVING/星期六/","content":"\n今天太操蛋了\n\n","categories":["LIVING"]},{"title":"node中我要退出程序，怎么做才能够确认一下再退出","url":"/2018/03/19/QUESTION/node中我要退出程序，怎么做才能够确认一下再退出/","content":"\n","categories":["QUESTION"]},{"title":"scrollreveal","url":"/2018/03/19/LIBRARY/scrollreveal/","content":"\n# scrollreveal\n\n\n\n\n# [github](https://github.com/jlmakes/scrollreveal)","categories":["LIBRARY"]},{"title":"vux","url":"/2018/03/19/LIBRARY/vux/","content":"\n# vux\n\n\n\n","categories":["LIBRARY"]},{"title":"REQUIRE.JS","url":"/2018/03/19/LIBRARY/require.js/","content":"\n# REQUIREJS\n实现AMD标准的库\n\n\n```\n\nrequirejs.config({\n    baseUrl:'/scripts',\n    paths:{\n        jquery:'./libs/jquery',\n        lazyload:'libs/jquery.lazyload.min'\n    },\n    shim:{\n        lazyload:{\n            deps:['jquery'],\n        }\n    }\n});\nrequire(['jquery','mods/center_ad','mods/loadImg'])\n```\n\n# 加载即执行\n\n# 模块定义\n\n## 函数式定义\n\n```\ndefine('mod_name',{})\n//不要写死模块名称，让requirejs更具路径来作为模块名\n```\n\n\n```\ndefine([\n  'mod1',\n  'mod2',\n], function (mod1,mod2) {\n  return {\n      a:1,\n      b:2\n  }\n});\n\n```\n\n## 对象式定义\n```\ndefine({\n    a:1,\n    b:2\n});\n\n```\n\n\n# 参考链接\n[官网](http://requirejs.org)\n[http://www.ruanyifeng.com/blog/2012/11/require_js.html](http://www.ruanyifeng.com/blog/2012/11/require_js.html)","categories":["LIBRARY"]},{"title":"qrcodejs","url":"/2018/03/19/LIBRARY/qrcodejs/","content":"\n\n\n\n","categories":["LIBRARY"]},{"title":"lodash","url":"/2018/03/19/LIBRARY/lodash.js/","content":"\n\n\n","categories":["LIBRARY"]},{"title":"jquery.form","url":"/2018/03/19/LIBRARY/jquery.form/","content":"\n\n","categories":["LIBRARY"]},{"title":"jquery.validation","url":"/2018/03/19/LIBRARY/jquery.validation/","content":"\n\n\n","categories":["LIBRARY"]},{"title":"bootstrap","url":"/2018/03/19/LIBRARY/jquery/","content":"\n\n\n","categories":["LIBRARY"]},{"title":"jquery.lazyload","url":"/2018/03/19/LIBRARY/jquery.lazyload/","content":"\n\n# 地址\n[github](https://github.com/tuupola/jquery_lazyload)\n\n# 示例\n```\n<img class=\"lazyload\"\n     src=\"thumbnail.jpg\"\n     data-src=\"original.jpg\"\n     width=\"1024\" height=\"768\" />\n```\n```\nlazyload();\n```\n","categories":["LIBRARY"]},{"title":"echarts","url":"/2018/03/19/LIBRARY/fullpage.js/","content":"\n\n\n","categories":["LIBRARY"]},{"title":"element-ui","url":"/2018/03/19/LIBRARY/element-ui/","content":"\n# element-ui\n\n\n\n","categories":["LIBRARY"]},{"title":"过渡和动画","url":"/2018/03/19/VUE/过渡和动画/","content":"\n","categories":["VUE"]},{"title":"组件","url":"/2018/03/19/VUE/组件/","content":"\n# 组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码\n\n# 注册组件\n- 全局注册\n```\nVue.component('my-component', {\n  // 选项\n})\nnew Vue({\n  el: '#some-element',\n  // 选项\n})\n```\n确保在初始化根实例**之前**注册组件\n- 局部注册\n\n\n# data必须是函数\n为什么？？？？？？\n很简单，如果不是data方法，如果多个组件同时使用的话，那么就会相互干扰，比如如果某个数据是一个对象的话，那么多个组件就会同时指向一个对象，修改其中一个组件，那么其他的组件中这个数据也会跟着变化\n\n#插槽 slot\n\n# 动态组件\n\n```\n<component v-bind:is=\"currentView\">\n  <!-- 组件在 vm.currentview 变化时改变！ -->\n</component>\n```\n其实就是两点\n- component特殊的html标签\n- is的使用\n\n\n#keep-alive\n\n如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数\n\n\n# 内置组件\n- component\n- transition\n- slot\n- keep-alive\n- \n- \n- \n- ","categories":["VUE"]},{"title":"echarts","url":"/2018/03/19/LIBRARY/echarts.js/","content":"\n\n\n","categories":["LIBRARY"]},{"title":"docute","url":"/2018/03/19/LIBRARY/docute/","content":"\n# 简介\n\ndocute 让你直接写 markdown 文件作为文档来显示而不需要编译成 html 这一步，你的文档目录里只需要一个首页 index.html 和你的配置文件 config.js。docute 会直接渲染这些 markdown 文件为一个单页应用。\n\n## 适合做文档\n\n[https://docute.js.org](https://docute.js.org)\n[https://github.com/egoist/docute](https://github.com/egoist/docute)\n\n\n\n","categories":["LIBRARY"]},{"title":"bootstrap","url":"/2018/03/19/LIBRARY/bootstrap/","content":"\n\n\n","categories":["LIBRARY"]},{"title":"侦听器","url":"/2018/03/19/VUE/侦听器/","content":"\n# 侦听器\n虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。","categories":["VUE"]},{"title":"基础笔记","url":"/2018/03/19/VUE/基础笔记/","content":"\n# VUE实例\n\n```\nvar app = new Vue({\n  el: \"#app\", //挂在根元素\n  data: {}, //数据\n  methods: {}, //方法\n  computed: {}, //计算属性\n  props: {}, //接收来自父组件的数据\n  propsData: {}, //创建实例时传递 props。主要作用是方便测试。\n  watch: {}, //一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象\n  template: '<h1>hello</h1>', //模板字符串\n  render:function (createElement) {\n    return createElement(\n      'h1'\n    )\n  }, //字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力,\n  renderError(h, err) {\n    return h('pre', {\n      style: {\n        color: 'red'\n      }\n    }, err.stack)\n  },//当 render 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 renderError。这个功能配合 hot-reload 非常实用\n  //钩子函数\n  beforeCreate:function(){},\n  created:function(){},\n  beforeMount:function(){},\n  mounted:function(){},\n  beforeUpdate:function(){},\n  updated:function(){},\n  activated:function(){},\n  deactivated:function(){},\n  beforeDestroy:function(){},\n  destroyed:function(){},\n  errorCaptured:function(){},\n  //钩子函数end\n  directives:{},//自定义指令\n  filters:{},//过滤器\n  components:{},//组件\n  parent:{},//指定已创建的实例之父实例\n  mixins:{},//混合\n  extends:{},//扩展\n  name:{},//组件名称\n  delimiters:{},//纯文本插入分隔符\n});\n\n\n```\n\n# 实例对象\n\n```\nconsole.log(app.$data);//\nconsole.log(app.$props);//\nconsole.log(app.$el);//\nconsole.log(app.$options);//\nconsole.log(app.$parent);//\nconsole.log(app.$root);//\nconsole.log(app.$children);//\nconsole.log(app.$slots);//\nconsole.log(app.$watch());//\nconsole.log(app.$set());//\nconsole.log(app.$delete());//\nconsole.log(app.$on());//\nconsole.log(app.$once());//\nconsole.log(app.$off());//\nconsole.log(app.$emit());//\nconsole.log(app.$mount());//\nconsole.log(app.$forceUpdate());//\nconsole.log(app.$destroy());//\n```\n\n# 指令\n- v-text\n- v-html\n- v-show\n- v-if\n- v-else\n- v-else-if\n- v-for\n- v-on\n- v-bind\n- v-model\n- v-pre\n- v-cloak\n- v-once\n\n\n\n# 用 key 管理可复用的元素\nhttps://cn.vuejs.org/v2/guide/conditional.html\n\n","categories":["VUE"]},{"title":"指令","url":"/2018/03/19/VUE/指令/","content":"# 指令 (Directives) 是带有 v- 前缀的特殊属性,指令属性的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)\n\n# 参数\n一些指令能够接收**一个**“参数”，在指令名称之后以冒号表示\n# 修饰符\n修饰符 (Modifiers) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定\n\n#缩写\n- `v-bind:href=\"url\"` 缩写 `:href=\"url\"`\n- `v-on:click=\"doSomething\"` 缩写 `@click=\"doSomething\"`\n","categories":["VUE"]},{"title":"slot","url":"/2018/03/19/VUE/slot/","content":"\n# slot\n可以说是父组件向子组件传递信息的一种方式\n\n父组件向子组件传递数据，就两种方式\n- props\n- slot","categories":["VUE"]},{"title":"事件处理","url":"/2018/03/19/VUE/事件处理/","content":"\n# v-on\n```\n <button v-on:click=\"counter += 1\">Add 1</button>\n <button v-on:click=\"function(){app.counter += 1}\">Add 1</button>\n```\n\n\n\n在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。","categories":["VUE"]},{"title":"vue-router","url":"/2018/03/19/VUE/vue-router/","content":"\n# vuejs的三大件\n- 模板引擎\n- 组件\n- 路由\n\n# vue-router\n\n当你要把 vue-router 添加进来，我们需要做的是，将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们\n\n# 三大步\n- 引入组件\n- 配置路由\n- 挂载\n\n```\n//引入组件\nvar nav={template:`<h1>sidebar page</h1>`};\nvar sidebar={template:'<h1>sidebar page</h1>'};\nvar home={template:'<h1>home page</h1>'};\nvar list={template:'<h1>list page</h1>'};\n\nvar routes=[\n    {path:'/',components:{nav:nav,sidebar:sidebar,default:home}},\n    {path:'/list',components:{nav:nav,sidebar:sidebar,default:list}}\n];\n\n//配置路由\nvar router=new VueRouter({\n    mode: 'history',\n    routes\n});\n\n//挂载\nvar app=new Vue({\n    el:\"#app\",\n    data:{\n        title:\"abc\"\n    },\n    router\n});\n```\n\n","categories":["VUE"]},{"title":"v-for","url":"/2018/03/19/VUE/v-for/","content":"\n# v-for 语法\n- `<li v-for=\"item in items\">`\n- `<li v-for=\"(item,key) in items\">`\n- `<li v-for=\"(item,key,index) in items\">`\n\n# in 可以替换成of\n- `<li v-for=\"item of items\">`\n- `<li v-for=\"(item,key) of items\">`\n- `<li v-for=\"(item,key,index) of items\">`\n\n# 如果items是array的话，是没有key的，只有index，`<li v-for=\"(item,key,index) of items\">` 这样写，不会报错，但是最后index就不存在了\n\n# key\n建议尽可能在使用 v-for 时提供 key\n还不是很清楚这个可以是干什么用的，先记住，for循环的时候，必须绑定key\n\n# 变异方法\n- push()\n- pop()\n- shift()\n- unshift()\n- splice()\n- sort()\n- reverse()\n只有这些使用这些方法的时候，vue才会自动更新视图，如果不是，将不更新\n比如，如果list是一个对象，那么将怎么做，都不会更新视图，所以，如果是列表的话，尽量使用array\n\n\n\n\n\n# 由于 JavaScript 的限制，Vue 不能检测以下变动的数组：\n- 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue\n- 当你修改数组的长度时，例如：vm.items.length = newLength\n\n\n\n# 一段取值范围的 v-for\n\n```\n<span v-for=\"n in 10\">{{ n }} </span>\n```\n\n# v-for with v-if\n当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用\n```\n <li v-for=\"(val,key,index) in list\" v-bind:key=\"index\" v-if=\"key=='title1'\">{{val}}--{{key}}--{{index}}</li>\n```\n这样我只会渲染出key==title1的数据，比如，我想渲染出带有hot标记的新闻，这招就很有用\n","categories":["VUE"]},{"title":"is到底怎么理解","url":"/2018/03/19/VUE/is到底怎么理解/","content":"\n# is\n\n","categories":["VUE"]},{"title":"typescript","url":"/2018/03/19/TYPESCRIPT/typescript/","content":"\n# 特点\n支持强类型\n\n# 官网\n[http://www.typescriptlang.org](http://www.typescriptlang.org)\n\n#在线编译和本地编译\n\n## 在线编译\n[http://www.typescriptlang.org/play/index.html](http://www.typescriptlang.org/play/index.html)\n## 本地编译\n```\ncnpm install typescript -g // 全局安装\n\ntsc -v//查看版本号\n\ntsc filename_path //编译\n\n\n```\n\n\n# 字符串\n1、自动拆分字符串\n\n\n# 参数类型\n\nnumber\nstring\nboolean\nvoid\nany\n\n```\nvar username:string;\n\nvar username:any=111;\nusername=true//正确\n\nfunction test:void(){}//函数没有返回值\nfunction test:number(){}//函数需要返回一个数字类型的返回值\nfunction test:number(val:string){}//函数需要返回一个数字类型的返回值,参数得是string类型\n\n\nclass Person{}\nvar p1:Person;//p1必须是Person类型\n```\n\n类型推断机制\n```\nvar username='asdf'//推断为string类型\nusername=111;//提示报错\n```\n\n# 默认参数\n默认值的参数必须放到后面\n```\nfunction test(val1:string,val2:number,val3:boolean=false){}\ntest('111',111);\n```\n# 可选参数\n默认值的参数必须放到后面\n```\nfunction test(val1:string,val2?:number,val3:boolean=false){}\ntest('111');\n```\n\n# rest & spread 操作符\n用来声明任意数量的方法参数,es6有这个方法\n```\nfunction test(...vals){}\nvar arr=[1,2,3];\ntest(...arr);\n```\n\n# generator函数\ntsc对es6规范的支持\n\n# 析构表达式\ntsc对es6规范的支持\n\n# 箭头表达式\n\n\n\n\n\n# privaite,protect,public(default)\ntsc 中，是有属性的访问限制符的，es6中没有\n\n# constructor()\ntsc对es6规范的支持\n\n# 泛型\n参数化的类型，一般用来限制集合的内容\n```\nvar arr:Array<number>;//arr是数组类型的，并且里面只能放number类型的数据\narr[1]=0;\narr[2]='asdf'//报错\n```\n\n# 接口\n**es6里面没有接口**\ninterface\n一共写法规范\n```\ninterface Person{\n    username:string;\n    age:number;\n}\nclass Student{\n    constructor(config:Person){//参数是Person设定的类型\n\n    }\n}\nvar s1=new Student({\n    username:'asdf',\n    age:11\n});//不能多也不能少\n```\n\n```\ninterface Person{\n    username:string;\n    age:number;\n    eat();\n}\nclass Student implements Person{\n    username:string;\n    age:number;\n    eat(){}\n}//实现这个接口的类必须满足接口的规定，否则报错\n\n```\n\n# 模块\ntsc对es6规范的支持\n\n\n# 注解\n？？？\n\n# 类型定义文件(*.d.ts)\n用来帮助开发者在tsc中使用已有的js包，如jquery\n\n```\nTypeScript 现在已经可以通过 npm install @types/库名 来安装类型定义文件了，这样可以把ts项目所需要的定义文件描述到npm包里，维护起来更加方便。\n```\n\n# 总结\n感觉tsc和es6很相似，多的东西有interface，参数类型定义(变成了强类型语言)，其他的感觉都一样\n\n# 强类型和弱类型\n变量x起先是一个数值，后来是一个字符串，类型完全由当前的值决定，这就叫弱类型。\n弱类型的好处是十分灵活，可以写出非常简洁的代码。但是，对于大型项目来说，强类型更有利，可以降低系统的复杂度，在编译时就发现类型错误，减轻程序员的负担\n","categories":["TYPESCRIPT"]},{"title":"生命周期","url":"/2018/03/19/REACT/生命周期/","content":"\n# 生命周期\n\n\n\n```\nimport React from 'react';\nclass shunxu extends React.Component {\n\n    constructor(props) {\n        super(props);\n    }\n    //mount start\n    componentWillMount() {}\n    render() {}\n    componentDidMount() {\n        //只能在浏览器端react调用,浏览器端不会被调用\n        //因为在服务器端，不存在dom装载这个过程，服务端得到的仅仅是一个字符串\n        //只要求在浏览器端做的事情，都可以在这个函数里面完成\n    }\n    //mount end \n    //update start\n    componentWillReceiveProps() {\n        //只要父组件的render函数被调用，子组件的该函数就会被调用\n    }\n    shouldComponentUpdate(nextProps,nextStates) {\n        //决定组件是否会渲染,注意，如果该函数一直返回false的话，那么首次加载渲染函数会被执行的，因为这个函数只是控制update过程是否渲染\n        return true;//必须有返回结果，如果返回false,componentWillUpdate,render,componentDidUpdate,就不会被执行\n    }\n    componentWillUpdate() {}\n    render() {}\n    componentDidUpdate() {}\n    //update end\n\n    //unmount start\n    componentWillUnmount(){}\n    //unmount end\n\n}\n```","categories":["REACT"]},{"title":"事件处理","url":"/2018/03/19/REACT/事件处理/","content":"\n## React 元素的事件处理和 DOM元素的很相似。但是有一点语法上的不同:\n\n- React事件绑定属性的命名采用驼峰式写法，而不是小写。\n- 如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串(DOM元素的写法)\n- 在 React 中另一个不同是你不能使用返回 false 的方式阻止默认行为。你必须明确的使用 preventDefault\n\n\n\n使用 React 的时候通常你不需要使用 addEventListener 为一个已创建的 DOM 元素添加监听器。你仅仅需要在这个元素初始渲染的时候提供一个监听器。\n\n当你使用 ES6 class 语法来定义一个组件的时候，事件处理器会成为类的一个方法。\n\n\n\n你必须谨慎对待 JSX 回调函数中的 this，类的方法默认是不会绑定 this 的。如果你忘记绑定 this.handleClick 并把它传入 onClick, 当你调用这个函数的时候 this 的值会是 undefined。","categories":["REACT"]},{"title":"jsx","url":"/2018/03/19/REACT/jsx/","content":"\n# jsx\n\n遇到 HTML 标签（以 < 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析\n\n\n推荐在 JSX 代码的外面扩上一个小括号，这样可以防止 分号自动插入 的bug\n\n\n编译之后呢，JSX 其实会被转化为普通的 JavaScript 对象\n\n\nReact 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。\n\n\n\n\n\n\nJSX 的特性更接近 JavaScript 而不是 HTML\n\n- 参考链接：http://www.ruanyifeng.com/blog/2015/03/react.html\n- 参考链接：https://doc.react-china.org/docs/introducing-jsx.html\n\n\n","categories":["REACT"]},{"title":"flux","url":"/2018/03/19/REACT/flux/","content":"\n\n# 一种软件架构思想\n\n![flux](/images/flux.png)\n\n本质上就是一个浏览器端的严格的MVC框架，\n起始服务器端的mvc框架是非常好用的，\n比如一个正常的mvc框架的流畅\n- 用户发送一个请求\n- 控制器\n- model\n- view\n然后改请求就完成了，想要继续其他操作，就要继续发送请求，周而复始\n\n但是在浏览器端，那么就不一样了，\n- 用户进行一个操作(发送一个请求)\n- control\n- model\n- view\n这个和后端差不多，但是问题就是，浏览器端的model和view都存在，这个时候，绝大多数情况下，使用直接在view中发送一个操作，直接修改model，因为这样省事，绕过了controller，这样就没有controller什么事了，问题就出在这里，导致混乱\n\nflux的核心问题就是解决view和model直线的问题，只能是model影响view，不能view影响model,所以要单项数据流\n\n\n\n# 四个部分\n- View： 视图层\n- Action（动作）：视图层发出的消息（比如mouseClick） (相当于tp框架中的一次http请求)\n- Dispatcher（派发器）：用来接收Actions、执行回调函数(相当于控制器)\n- Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面(相当于model)\n\n# Flux 的最大特点，就是数据的\"单向流动\"\n\n- 用户访问 View\n- View 发出用户的 Action\n- Dispatcher 收到 Action，要求 Store 进行相应的更新\n- Store 更新后，发出一个\"change\"事件\n- View 收到\"change\"事件后，更新页面\n\n\n","categories":["REACT"]},{"title":"props&&state","url":"/2018/03/19/REACT/props&&state/","content":"\n# props\n\n父组件传递数据给子组件的一种方式\n注意点：\n- props万万不要修改，应该在初始化的时候，将其传递给state\n- 模板中不要使用props，虽然可以使用，但是模板中更应该使用state，应为state表示组件的状态\n\n```\n//父组件\n<parent>\n    <child name=\"p2c\"></child>\n</parent>\n\n```\n\n```\n//子组件\n<h1>\n  {this.props.name} \n</h1>\n\n```\n\n# state\n组件内部状态\n\n构造函数是唯一能够初始化 this.state 的地方\n\n## 初始化\n```\nconstructor(props){\n    super(props);\n    this.state={\n        name:111\n    }\n}\n```\n## 修改\n\n```\nthis.setState({\n    name:222\n})\n\n```\n如果state非常大，我可以只更新其中的一部分吗? **可以**\n\n# 组件渲染时机\n\n只要子组件的state通过this.setState()改变后，那么就会重新渲染\n","categories":["REACT"]},{"title":"ajax如何实现跨域","url":"/2018/03/19/PHP/ajax如何实现跨域/","content":"\n# 很简单 :**header('access-Control-Allow-Origin:*');**\n设置完该属性后，可以让所有ajax访问，没有域名限制\n```\n<?php\n\n//access-Control-Allow-Origin\nheader('access-Control-Allow-Origin:*');\n$arr=[\n   [\"title\"=>'标题',\"con\"=>\"con1111\"],\n   [\"title\"=>'标题',\"con\"=>\"con1111\"],\n   [\"title\"=>'标题',\"con\"=>\"con1111\"],\n   [\"title\"=>'标题',\"con\"=>\"con1111\"],\n   [\"title\"=>'标题',\"con\"=>\"con1111\"],\n];\n    \n    echo json_encode($arr);\n?>\n```\n","categories":["PHP"]},{"title":"react-router","url":"/2018/03/19/REACT/react-router/","content":"# 组件库\n- react-router React Router 核心\n- react-router-dom 用于 DOM 绑定的 React Router\n- react-router-native 用于 React Native 的 React Router\n- react-router-redux React Router 和 Redux 的集成\n- react-router-config 静态路由配置帮助助手\n\n# web应用，应该引入哪个？\nreact-router-dom,就这一个就好\n如果搭配了redux的话，还要使用react-router-redux\n\n# 基本案例\n```\nimport { Route, BrowserRouter, Link ,Switch,Redirect} from 'react-router-dom';\n <Router>\n    <div>\n      <ul>\n        <li><Link to=\"/\">首页</Link></li>\n        <li><Link to=\"/about\">关于</Link></li>\n        <li><Link to=\"/topics\">主题列表</Link></li>\n      </ul>\n      <hr/>\n      <Route exact path=\"/\" component={Home}/>\n      <Route path=\"/about\" component={About}/>\n      <Route path=\"/topics\" component={Topics}/>\n    </div>\n  </Router>\n```\nlink默认会渲染出a链接，点击link会改变url地址，然后react会更具url，来匹配Route对应出来的组件，渲染出组件\n\n但是上面的代码会报错\n为什么？？？\nweb应用中需要使用\nBrowserRouter\n\n```\nimport { Route, BrowserRouter, Link ,Switch,Redirect} from 'react-router-dom';\n <BrowserRouter>\n    <div>\n      <ul>\n        <li><Link to=\"/\">首页</Link></li>\n        <li><Link to=\"/about\">关于</Link></li>\n        <li><Link to=\"/topics\">主题列表</Link></li>\n      </ul>\n      <hr/>\n      <Route exact path=\"/\" component={Home}/>\n      <Route path=\"/about\" component={About}/>\n      <Route path=\"/topics\" component={Topics}/>\n    </div>\n  </BrowserRouter>\n```\n\n# BrowserRouter子元素只能是一个\n\n```\n <BrowserRouter>\n      <ul>\n        <li><Link to=\"/\">首页</Link></li>\n        <li><Link to=\"/about\">关于</Link></li>\n        <li><Link to=\"/topics\">主题列表</Link></li>\n      </ul>\n      <hr/>\n      <Route exact path=\"/\" component={Home}/>\n      <Route path=\"/about\" component={About}/>\n      <Route path=\"/topics\" component={Topics}/>\n  </BrowserRouter>\n```\n这样会报错的\n\n# 假如我想将Link和Route分到不同的子组件中，会怎么样？？？？\n\n比如：\nheader.jsx:\n```\n<ul>\n    <li><Link to=\"/\">首页</Link></li>\n    <li><Link to=\"/about\">关于</Link></li>\n    <li><Link to=\"/topics\">主题列表</Link></li>\n</ul>\n```\nmain.jsx\n```\n<Route exact path=\"/\" component={Home}/>\n<Route path=\"/about\" component={About}/>\n<Route path=\"/topics\" component={Topics}/>\n```\n\napp.jsx\n\n```\n<div>\n    <header><header/>\n    <main><main/>\n</div>\n```\n这种情况其实也很常见\n结果会怎样？？？？\n点击link，url会改变，但是route部分不会渲染，也就是说只修改了url\n\n但是刷新本页面的话，会则会匹配到对应的route\n\n也就是说，link和route不会同步了\n\n怎么办？？？？？\n\n\n\n\n# 参考\n- http://www.jianshu.com/p/6a45e2dfc9d9\n- http://www.jianshu.com/p/e3adc9b5f75c\n- http://www.zcfy.cc/article/react-router-v4-the-complete-guide-mdash-sitepoint-4448.html","categories":["REACT"]},{"title":"redux","url":"/2018/03/19/REACT/redux/","content":"\n# flux 和redux的区别\n最大的区别就是只能有一个store\n\n# 设计思想\n- Web 应用是一个状态机，视图与状态是一一对应的。\n- 所有的状态，保存在一个对象里面。\n\n# 三原则\n- 唯一数据源\n- 状态保持只读\n- 数据改变只能通过纯函数完成\n\n# 唯一数据源\n说白了，就是单一store\n多个store之间可能存在依赖，比如CounterSummary就依赖于CounterStore，并且这两个store中都要设置外露回调函数，所以有冗余\n这其实就导致了另外一个问题，就是store的解构问题，这个问题将会是一个核心问题\n\n# 状态保持只读\n就是store中的数据不要直接修改，\n\nUI=render(state);\n## 不修改状态，怎么改变view\n改变状态的方法不是去直接修改状态上的值，而是创建一个**新的**状态对象返回给redux\n\n\n#数据改变只能通过纯函数完成\n纯函数就是reducer\nredux=flux + reducer\n\n# reducer到底是个什么东西?\n简单说就是定义store数据更新规则,\n用法\n```\nreducer(state , action }\n```\n看用法，说白了reducer就是一个函数，这个函数根据state和action来返回一个全新的数据\n\n\nreducer 必须是纯函数，也就是说函数的返回结果必须完全由参数state 和action 决定，而且不产生任何副作用，也不能修改参数state 和action 对象。\n\nRedux的reducer 只负责计算状态，却并不负责存储状态。\n\n\n\n\n# Store设计原则\n- 避免数据冗余\n\n\n\n# 常用方法\n- store.getState():获取store状态\n- store.dispatch():派发action，因为action是数据，所以也就是派发数据\n- store.subscribe():注册回调函数,action是向store发送修改数据的请求，修改后，需要重新获取store的数据，什么时候获取，就通过注册回调函数就可以了\n- const Store=createStore(Reducer,VALS);创建store\n\n\n\n\n```\n\n\n```\n\n\n在Redux 中， action 构造函数只负责创建对象，要派发action 就\n需要调用store.dispatch 函数。\n\n\n#先写哪个？\nActionTypes->Actions->Reducer\n\n\n#只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。\n\n\n# 用户只能接触到view\n# Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化\n\n# store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法\n\n# Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数\n\n# Store \n- store.getState()\n- store.dispatch()\n- store.subscribe()\n\n# state和store是不同的\nstate表示当前时间的store的副本，store的数据是会变化的，state不会，因为他表示某一个时刻的状态","categories":["REACT"]},{"title":"node文件当作命令来执行","url":"/2018/03/19/NODEJS/node文件当作命令来执行/","content":"\n\nlinux中的test.js文件，头部添加这样一段话\n\n```\n#!/usr/bin/env node\n```\n\n```\n./test.js   #执行这样的命令的话，就可以直接运行test.js了，如果没有这句话，需要使用 node ./test.js才可以\n```\n\n\n# window中怎么做?????","categories":["NODEJS"]},{"title":"npm","url":"/2018/03/19/NODEJS/npm/","content":"#\n查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的npm run命令。\n\n# 最重要的命令\n\nnpm help:列出所有的命令\nnpm -l :列出所有命令的详细信息\n\n```\nnpm <command> -h     quick help on <command>\nnpm -l           display full usage info\nnpm help <term>  search for help on <term>\nnpm help npm     involved overview\n```\n\n### npm 内置了两个命令简写，npm test 等同于执行 npm run lint，npm start 等同于执行 npm run start。\n\n### 两个命令中间用&&连接，表示执行完一个后执行另一个。如果希望两个命令同时平行执行，它们中间可以用&连接。\n\n#简化命令\n--save:-S\n--save-dev:-D\ninstall:i\n\n# 钩子函数\n\n```\n\"scripts\": {\n    \"pretest\": \"echo 'pretest'\",\n    \"test\": \"echo 'test'\",\n    \"posttest\": \"echo 'posttest'\",\n  },\n```\nnpm run为每条命令提供了pre和post两个钩子（hook）\n\n# 参考文章\n\n[https://www.kancloud.cn/kancloud/javascript-standards-reference/46497](https://www.kancloud.cn/kancloud/javascript-standards-reference/46497)\n","categories":["NODEJS"]},{"title":"stream","url":"/2018/03/19/NODEJS/stream/","content":"\n# 可读数据流\n\n\n## 方法\n- read():系统缓存读取并返回数据,该方法可以接受一个整数作为参数，表示所要读取数据的数量，然后会返回该数量的数据。如果读不到足够数量的数据，返回null。如果不提供这个参数，默认返回系统缓存之中的所有数据\n- pause():暂停读取\n- resume():恢复读取\n- setEncoding():设置编码\n- isPaused():是否暂停\n- pipe():\n- unpipe()\n## 事件\n- readable\n- data\n- end\n- close\n- error\n\n\n\n\n# 可写数据流\n\n\n## 方法\n- write():向“可写数据流”写入数据,它接受两个参数，一个是写入的内容，可以是字符串，也可以是一个stream对象（比如可读数据流），另一个是写入完成后的回调函数\n- setDefaultEncoding()\n- end():end方法用于终止“可写数据流”。该方法可以接受三个参数，全部都是可选参数。第一个参数是最后所要写入的数据，可以是字符串，也可以是stream对象；第二个参数是写入编码；第三个参数是一个回调函数，finish事件触发时，会调用这个回调函数。\n## 事件\n- drain:writable.write(chunk)返回false以后，当缓存数据全部写入完成，可以继续写入时，会触发drain事件。\n- finish\n- pipe\n- unpipe\n- error\n\n\n# 可读写数据流\n\n\n\n# 哪些是可读数据流\nhttp.request\nfs.createReadStream\nprocess.stdin\n\n# 哪些是可写数据流\nhttp.response\nfs.createWriteStream\nprocess.stdout\n\n\n# 总结\n按照分类来记忆，一共就分为两大类，可写和可读数据流，这个需要分清楚，可写数据流有哪些方法和事件，可读数据流有哪些方法和事件\n然后记住那些常见的对象有可写数据流接口和可读数据流接口\n\n# 问题\n- 如何自己写一个对象，让这个对象拥有stream接口呢？\n\n\n","categories":["NODEJS"]},{"title":"svg","url":"/2018/03/19/OTHER/svg/","content":"\n#SVG\n\n\n# 基本图形\n- ##rect:矩形\n    ### 属性\n        + x:左上角x轴坐标\n        + y:左上角y轴坐标\n        + rx:圆角\n        + ry:圆角\n- circle:圆\n    ### 属性\n        + cx:圆点的x坐标\n        + cy:圆点的y坐标\n        + r:半径\n- ellipse:椭圆\n    ### 属性\n        + cx:圆点的x坐标\n        + cy:圆点的y坐标\n        + rx:水平半径\n        + ry:垂直半径\n- line:直线\n    ### 属性\n        + x1 属性在 x 轴定义线条的开始\n        + y1 属性在 y 轴定义线条的开始\n        + x2 属性在 x 轴定义线条的结束\n        + y2 属性在 y 轴定义线条的结束\n- polygon:多边形\n    ### 属性\n        + point:x1,y1 x2,y2 x3,y3(坐标用逗号分隔，每个点之间用空格分隔)\n- polyline:曲线\n    ### 属性\n       + point:x1,y1 x2,y2 x3,y3(坐标用逗号分隔，每个点之间用空格分隔)\n- path\n    ### 属性\n        + d:定义路径的规则\n        ```\n        <path d=\"M150 0 L75 200 L225 200 Z\" />\n\n        <path d=\"M10,0 L30,60 L90,30 Z\"\n                 fill=\"red\" stroke=\"blue\" stroke-width=\"1\" />\n        ```\n        一条路径，它开始于位置150 0，到达位置75 200，然后从那里开始到225 200，最后在150 0关闭路径\n        M:表示开始\n        Z:闭合路径\n- text\n    ### 属性\n        + x:左上坐标\n        + y:左上坐标\n\n# Stroke 属性\n- stroke\n- stroke-width\n- stroke-linecap\n- stroke-dasharray\n\n\n# SVG 滤镜\n# SVG 模糊效果\n","categories":["OTHER"]},{"title":"YAML","url":"/2018/03/19/OTHER/yaml/","content":"\nYAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。\n\n### 它的基本语法规则如下。\n\n- 大小写敏感\n- 使用缩进表示层级关系\n- 缩进时不允许使用Tab键，只允许使用空格。\n- 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可\n\n`#` 表示注释，从这个字符一直到行尾，都会被解析器忽略。\nYAML 支持的数据结构有三种。\n\n- 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）\n- 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）\n- 纯量（scalars）：单个的、不可再分的值\n\n\n\n{% blockquote [author[, source]] [link] [source_link_title] %}\ncontent\n{% endblockquote %}\n","categories":["OTHER"]},{"title":"fs","url":"/2018/03/19/NODEJS/fs/","content":"\n\n# 文件的读写\n\n常见情况\n- 列出当前目录下面的所有文件，(文件名称，文件类型)\n- 文件的写入(添加，重写)\n- 文件的读取\n- 文件的删除\n- 文件的创建，文件夹的创建\n\n## 写一个函数，可以查看指定目录下面的所有文件，包括文件夹,如果是文件，则读取文件的头100个字符来查看\n\n```\n\n\nvar fs=require('fs');\nlet resArr=[];//存储结果\nfs.readdir('./',function(err,files){\n    if(err){\n        console.log(err);\n    }\n    files.forEach(function(val){\n        var stat=fs.statSync(val);\n        if( stat.isDirectory()  ){\n            // type:dir,title:'dir_name'\n            resArr.push({type:'dir',title:val});\n        }else{\n            //type:file,title:'file_name',\n            var con=fs.readFileSync(val).slice(0,100);\n            resArr.push({type:'file',title:val,con:con.toString()});\n        }\n    });\n    console.log(resArr);\n});\n\n\n\n```\n\n","categories":["NODEJS"]},{"title":"http","url":"/2018/03/19/NODEJS/http/","content":"\n\n## 模块方法\n- createServer(callback)：创造服务器实例。\n\n## 服务器实例的方法\n- listen(port)：启动服务器监听指定端口。\n\n## HTTP回应的属性\n- headers：HTTP请求的头信息。\n- url：请求的路径。\n\n## HTTP回应的方法\n- setHeader(key, value)：指定HTTP头信息。\n- write(str)：指定HTTP回应的内容。\n- end()：发送HTTP回应。\n\n\n\n## 常见问题\n- 如何搭建一个基础班的服务器\n- 如何搭建一个静态服务器\n- 如何获得一个静态页面的内容 wget\n- 如何获得一个页面中所有的css\n- 如何获得一个页面中所有的图片\n- 如何curl????\n\n## 如何搭建一个基础班的服务器\n\n```\nvar http=require('http');\nvar process=require('process');\nvar args=process.argv.slice(2);\nvar server=http.createServer(function(request,response){\n    console.log(request.url);\n});\n\nvar host=(typeof args[0] != \"undefined\") ? args[0] : '127.0.0.1';\nvar port=(typeof args[1] != \"undefined\") ? args[1] : 3000;\n\nserver.listen(port,host,function(){\n    console.log(`server start at http://${host}:${port}`);\n});\n\n```\n\n## 如何搭建一个静态服务器\n\n```\n//通过127.0.0.1:3000/1.jpg,可以看到test目录下面的图片\nvar http = require('http');\nvar process = require('process');\nvar path = require('path');\nvar fs = require('fs');\nvar args = process.argv.slice(2);\nvar server = http.createServer(function (request, response) {\n    request.setEncoding('utf-8');\n    var file = path.join(__dirname, 'test', request.url);\n    fs.stat(file, function (err, stat) {\n        if (err) {\n            console.log(err);\n            response.end('报错了');\n        }\n        if (stat &&stat.isFile()) {\n            var stream = fs.createReadStream(file);\n            response.writeHead(200, {'Content-Type': 'image/jpeg'});\n            var res = fs.readFileSync(file);\n            response.end(res);\n            response.on('end', function () {\n                console.log('传输完成');\n            })\n        } else {\n            response.writeHead('404',{\"Content-Type\":\"text/plain\"});\n            response.write('查找文件不存在');\n            response.end();\n        }\n    });\n\n\n    request.on('error', function (e) {\n        console.log('problem with request: ' + e.message);\n    });\n    response.on('error', function (e) {\n        console.log('problem with request: ' + e.message);\n    });\n\n});\n\nvar host = (typeof args[0] != \"undefined\") ? args[0] : '127.0.0.1';\nvar port = (typeof args[1] != \"undefined\") ? args[1] : 3000;\n\nserver.listen(port, host, function () {\n    console.log(`server start at http://${host}:${port}`);\n});\n//有报错，不知道为什么\n```\n\n\n## 如何获得一个静态页面的内容\n```\nvar http = require('http');\nvar fs = require('fs');\nvar url='http://www.baidu.com';\nhttp.get(url,function(client){\n    var res;\n    client.on('data',function(e){\n        res+=e;\n    });\n    client.on('end',function(){\n        fs.writeFile('baidu.html',res);\n    })\n})\n```\n\n\n## 获取指定页面的所有图片\n\n```\n//通过127.0.0.1:3000/1.jpg,可以看到test目录下面的图片\nvar http = require('http');\nvar process = require('process');\nvar path = require('path');\nvar fs = require('fs');\nvar URL=require('url');\nvar args = process.argv.slice(2);\n//获得网页中所有的图片\nvar target='http://m.lianqiwenhuaw.com/';\n\nhttp.get(target,function(client){\n    var data;\n    client.on('data',function(e){\n        data+=e;\n    });\n    client.on('end',function(){\n        var imageUrls=data.match(/src=\"[a-zA-Z0-9_\\/\\.]*[jpg|png|gif]\"/g);\n        imageUrls.forEach(function(val) {\n            val=val.replace(/[\"|']/g,'').replace('src=','');\n            var old=val;\n            val='http://'+path.join('m.lianqiwenhuaw.com',val);\n            // console.log(val);\n            http.get(val,function(client){\n                var data;\n                client.on('data',function(e){\n                    data+=e;\n                });\n                client.on('end',function(){\n                    var file_name=old.split(/\\//g).reverse()[0];\n                    // console.log(file_name);\n                    fs.writeFile(path.join(__dirname,'test',file_name),data);//这样得到的图片显示图片损坏，到底哪里出了问题\n                });\n            });\n        }, this);\n        \n        // console.log(imagesUrl);\n    })\n})\n\n```","categories":["NODEJS"]},{"title":"koa","url":"/2018/03/19/NODEJS/koa/","content":"\n# koa\n\n# 中间件执行流程\n\n\n\n\n\n# 参考资料\n\n[https://www.kancloud.cn/kancloud/javascript-standards-reference/46487](https://www.kancloud.cn/kancloud/javascript-standards-reference/46487)","categories":["NODEJS"]},{"title":"express","url":"/2018/03/19/NODEJS/express/","content":"\n# express\n\n# 中间件执行流程\n\n```\napp.get('*',function (req,res,next) {\n  console.log(2222);\n  next();\n  console.log(33333);\n});\n\n\napp.get('/',function (req,res,next) {\n  console.log(44444)\n  res.send('hahaha');\n  console.log(55555);\n  // next();\n});\n```\n输出循序：2,4,5,3;\n洋葱模型\n\n\n# 练手项目\n\n[gitee.com/feibenren/express_demo](gitee.com/feibenren/express_demo)\n\n\n通过这项目，发现了一些问题\n1、mysql数据库不怎么好用\n2、就一个基本的框架，其他的东西都得自己写\n3、回调\n","categories":["NODEJS"]},{"title":"错误处理","url":"/2018/03/19/JAVASCRIPT/错误处理/","content":"\n无论输入，finally都会执行，所以，这个finally觉得没什么用\n\n```\ntry{\n    console.log(111);\n    setTimeout(function() {\n        throw new Error('setTimeout err');  \n    }, 2000);\n}catch(e){\n    console.log('catch:');\n    console.log(e);\n}finally{\n    console.log('finally');\n}\n\nconsole.log('after try');\n```\n\n> try catch 有一个问题，针对回调，定时任务等需要等一段时间的报错，无法处理","categories":["JAVASCRIPT"]},{"title":"assert","url":"/2018/03/19/NODEJS/assert/","content":"\n## assert模块是Node的内置模块，主要用于断言。如果表达式不符合预期，就抛出一个错误。\n\n```\nvar assert = require('assert');\n\nfunction add (a, b) {\n  return a + b;\n}\n\nvar expected = add(1,2);\nassert( expected === 4, '预期1加2等于3');//这样的话，系统就会报错，如何捕获这个错误？？？没法捕获，这个模块主要用来测试使用\n```","categories":["NODEJS"]},{"title":"eventEmitter","url":"/2018/03/19/NODEJS/eventEmitter/","content":"\n# 在NODE中如何给一个对象绑定事件呢？？\n```\n//var p1=new Person('wangbing');\n//p1.addEventLister('xxx',()=>{});//这样操作是不正确的，因为在node中，没有dom元素了，所以，不能通过addEventListener来绑定事件，那么怎么办呢?\n\n```\n\n","categories":["NODEJS"]},{"title":"覆盖&& 融合","url":"/2018/03/19/JAVASCRIPT/覆盖&& 融合/","content":"\n$.extend();\n\n","categories":["JAVASCRIPT"]},{"title":"解构赋值","url":"/2018/03/19/JAVASCRIPT/解构赋值/","content":"\n```\n{ //数组解构赋值\n    let a, b, c;\n    [a, b] = [1, 2];\n    console.log(a, b);\n}\n\n{ //数组解构赋值\n    let a, b, c;\n    [a, b, c] = [1, 2, 3, 4, 5, 6];\n    console.log(a, b, c);\n}\n\n{ //对象解构赋值\n    let a, b, c;\n    ({ a, b } = { a: 1, b: 2 }); //一定要加小括号，因为大括号不能开头\n    console.log(a, b);\n}\n```\n\n## 默认值\n\n```\n{ //数组解构赋值\n    let a, b, c;\n    [a, b,c=3] = [1, 2];\n    console.log(a, b);\n}\n```\n\n常见用途\n- 变量交换\n- 函数直接返回数组，可以直接对应赋值，非常方便\n\n\n\n\n## 变量交换\n```\nlet a = 1;\nlet b = 2;\n[a, b] = [b, a];\nconsole.log(a, b);\n```\n## 函数返回数组或对象，直接解构\n```\nfunction getUserInfo() {\n    var res = {\n        username: 'wangbing',\n        sex: 'male'\n    }\n    return res;\n}\n\nlet { username, sex } = getUserInfo(); //不用先声明，在解构，直接let\nconsole.log(username, sex);\n```\n\n","categories":["JAVASCRIPT"]},{"title":"^&&~","url":"/2018/03/19/NODEJS/^&&~/","content":"\n\n```\nnpm install jquery@^2.1.1 --save   || 1.0 或者 1.0.x 或者 ~1.0.4\nnpm install jquery@~2.1.1 --save   || 1 或者 1.x 或者 ^1.0.4\n```\n# 版本：大.中.小\n\n## ~1.2.2:规定中版本号不能变，小版本号取最大\n## ^1.2.1:规定大版本号不能变，中版本号取最大\n## lastest：最新","categories":["NODEJS"]},{"title":"闭包","url":"/2018/03/19/JAVASCRIPT/闭包/","content":"\n## 闭包（closure）就是定义在函数体内部的函数。\n\n## 闭包就是能够读取其他函数内部变量的函数\n\n```\nfunction a(){\n    var b=function(){\n        console.log('bbbbb');\n    }\n    return b;\n}\n\n```\n# 闭包优势\n- 安全，只有通过返回的对象才可以操作闭包中的内容\n- 让变量始终保持在内存中\n\n\n\n\n# 缺点\n- 可能导致内存泄漏\n\n# 为什么js会出现这种怪异的东西\n\n我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现\n\n\n\n\n\n# 闭包作用\n- 减少全局变量\n- 隐藏变量\n=====>构造模块","categories":["JAVASCRIPT"]},{"title":"类数组对象","url":"/2018/03/19/JAVASCRIPT/类数组对象/","content":"\n下面就是一个类似数组的对象。\n```\nvar a = {\n    0:'a',\n    1:'b',\n    2:'c',\n    length:3\n};\n\na[0] // 'a'\na[2] // 'c'\na.length // 3\n```\n上面代码的变量a是一个对象，但是看上去跟数组很像。所以只要有数字键和length属性，就是一个类似数组的对象。当然，变量a无法使用数组特有的一些方法，比如pop和push方法。而且，length属性不是动态值，不会随着成员的变化而变化。\n\n\n- arguments对象\n- 大多数DOM元素集\n- 字符串\n","categories":["JAVASCRIPT"]},{"title":"浏览器端数据储存机制","url":"/2018/03/19/JAVASCRIPT/浏览器端数据储存机制/","content":"\n\n这个API的作用是，使得网页可以在浏览器端储存数据。它分成两类：sessionStorage和localStorage。\n\n\n## 存入/读取数据\n\n```\nsessionStorage.setItem('s1','ssssss');\nlocalStorage.setItem('l1','ssssss');\n\n\n\nsessionStorage.getItem('s1')\nlocalStorage.getItem('l1');\n```\n清除数据\n\n```\nsessionStorage.removeItem('s1')\nlocalStorage.removeItem('l1');\n\nsessionStorage.clear();//all\nlocalStorage.clear();//all\n```\n\n遍历操作\n\n```\nfor(var i = 0; i < localStorage.length; i++){\n    console.log(localStorage.key(i));\n}\n```","categories":["JAVASCRIPT"]},{"title":"自动添加封号","url":"/2018/03/19/JAVASCRIPT/自动添加封号/","content":"一般来说，在没有分号结尾的情况下，如果下一行起首的是(、 [ 、+、-、/这五个字符中的一个，分号不会被自动添加。只有下一行的开始与本行的结尾，无法放在一起解释，JavaScript引擎才会自动添加分号。\n\n\n> 由于解释引擎自动添加分号的行为难以预测，因此编写代码的时候不应该省略行尾的分号。","categories":["JAVASCRIPT"]},{"title":"获得三天后的时间","url":"/2018/03/19/JAVASCRIPT/获得三天后的时间/","content":"\n```\n{\n    var res_date=new Date( Date.now() + 3600*24*3*1000);\n}\n{\n    var date=new Date();\n\n    var res_date= new Date( date.getTime() + 3600*24*3*1000);\n}\n```\n\n\n","categories":["JAVASCRIPT"]},{"title":"浏览器端数据库：IndexedDB","url":"/2018/03/19/JAVASCRIPT/浏览器端数据库/","content":"\n\n","categories":["JAVASCRIPT"]},{"title":"正则","url":"/2018/03/19/JAVASCRIPT/正则/","content":"\n正则方法\n- test\n- exec\n\n字符串方法\n- match\n- search\n- replace\n- split\n\n修饰符\n- g(global)修饰符:全局匹配（默认情况下，第一次匹配成功后，正则对象就停止向下匹配了），默认false\n- i(ignore case)修饰符：忽略大小写（ignorecase），默认false\n- m(multi lines)多行搜索，默认false\n\n\n# 正则表达式由两种基本字符类型组成\n- 原意文本字符:\n- 元字符:比如\\d,\\w,+?*~\n\n\n# 预定义模式\n- . [^\\r\\n] 回车换行以外的所有字符\n- \\d 匹配0-9之间的任一数字，相当于[0-9]。digit\n- \\D 匹配所有0-9以外的字符，相当于[^0-9]。\n- \\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。word\n- \\W 除所有字母、数字和下划线以外的字符，相当于/[^A-Za-z0-9_]/ 。\n- \\s 匹配空格（包括制表符、空格符、断行符等），相等于[\\t\\r\\n\\v\\f]。whitespace\n- \\S 匹配非空格的字符，相当于[^\\t\\r\\n\\v\\f]。\n\n\n# ^，不同的位置有不同的意思，特别贱\n- 在[]号中，表示取反\n- 不在[]中，表示开头\n\n# $也同上\n\n\n- \\b 匹配词的边界。\n- \\B 匹配非词边界，即在词的内部。\n\n\n# 特殊字符\n- \\n 换行键 \n- \\r 回车键 \n- \\t 制表符tab  \n\n\n\n\\r,\\n,\\r\\n 有什么异同\n\n[https://zhidao.baidu.com/question/386412786.html](https://zhidao.baidu.com/question/386412786.html)\n\n并没有异同。\n\\r 和 \\n 好像都是以前的那种打字机传承来的。\n\\r 代表回车，也就是打印头归位。\n\\n代表换行，就是走纸。\nlinux只用\\n换行。\nwin下用\\r\\n表示换行\n\n\n\n\n\n\n\n# 括号\n- []:one of，只要匹配其中的一个即可\n- ():group\n- {}:times 循环次数\n\n\n# 边界\n- ^ 以XXX开始\n- $ 以xxx结束\n- \\b 单词边界\n- \\B 非单词边界\n\n\n```\nvar result = \"I\\nlove\\njavascript\".replace(/^|$/gm, '#');\nconsole.log(result);\n\n\n/*\n#I#\n#love#\n#javascript#\n*/\n\n```\n\n\n```\nvar result = \"I\\nlove\\njavascript\".replace(/^|$/g, '#');\nconsole.log(result);\n\n\n/*\n#I\nlove\njavascript#\n*/\n\n```\n添加了m,就表示这是多行匹配模式，没有添加m，就表示单行匹配模式\n\n\n# 量词\n- ? === {0,1} 0或者一次\n- + === {1,} 1或多次\n- * === {0,} 0或多次\n- {n}\n- {n,m}\n- {n,}\n\n注意\n\n```\nasdf{3}\n```\n表示的意思是，匹配asd，然后f连续出现3次\n也就是说，量词默认是作用于紧紧相连的单词的，不相连的不作用于，因为我根本不知道我需要作用于到哪里啊\n\n如果想好实现asdf连续出现3次，怎么办？\n需要分组\n\n```\n(asdf){3}\n```\n\n注意:{,2}表示最多两次，是错误的，这样表示的就是字符串 '{,2}'\n应该{0,2}表示最多两次\n\n# 贪婪模式&非贪婪模式\n正则是默认贪婪模式\n```\n\\d{3,6}\n\n12345678910\n\n```\n比如这样，正则默认是这样匹配的\n123456，78910\n正则会最先匹配6个连着的，然后是5个...\n但是，加入我想实现最先匹配3个，然后是4个...，怎么办？\n\n```\n\\d{3,6}?\n\n12345678910\n\n```\n123,456,789\n10不够3个，就不匹配\n\n非贪婪模式，很简单，只要在量词后面添加?即可\n\n# 分组\n()可以达到分组的功能，使量词作用于分组\n```\n(abc){3}\n```\n分组还有一种情况\n```\naa(a|b)bb\n```\n这样的话，就表示可以匹配到aaabbb,aabbb,\n\n如果不加的话\n```\naaa|bbb\n```\n这样就表示，匹配到的东西就是,aaa,bbb，性质就完全不一样了\n\n\n# 分组的反向引用\n```\n2018-3-14\n替换成\n14/3/2018\n```\n怎么做，这就有点像变量的概念了\n\n```\n'2018-3-14'.replace(/(\\d+)-(\\d+)-(\\d+)/,'$3-$2-$1')\n```\n$1,$2,$3,表示的就是第一个分组，第二个分组，第三个分组，这样我就可以自由替换了\n\n如果我不想捕获分组，那么只需要加上'?:'即可\n\n```\n(?:\\d+)-(\\d+)-(\\d+)\n```\n注意，必须在(的后头添加，否则，?:就表示其他意思了\n\n```\n(\\d+?:) \n```\n这样表示的就是\\d一个或多个，然后加上一个字符:\n\n\n# 前 \n就是说正则在匹配的时候，是从前往后开始解析的，这叫做前\n\n# 后\n和前相反，从后往前解析\n\n# 前瞻\n正则在匹配到规则的时候，向前检查是否符合断言(注意，断言不是正则匹配的一部分，例子中有说明)\n\n\n# 后顾\n和前瞻正好相反\njs不支持后顾，不说\n\n## 正向前瞻|肯定前瞻， exp(?=assert)\n符合某个断言的前瞻\n## 反向前瞻|否定前瞻，exp(?!assert)\n不符合某个断言的前瞻\n\n例子\n```\n\\w(?=\\d)\n```\n意思就是说，一个字符后面，必须得是数字，\n注意，这个正则匹配到的仅仅是字符，不包含断言，也就是数字\n这就是肯定前瞻\n\n\n```\n\\w(?!\\d)\n```\n和上面例子正好相反，字符后面不能是数字\n这就是否定前瞻\n\n\n\n\n\n\n\n\n\n\n# 范围类\n[0-9]\n[a-zA-Z]\n[a-z]:必须放到[]中，因为只有放到[]中，才能表示其中一个，放到()中，那么久成了一个'a-z'的字符串了\n\n注意，只有这种情况下，才表示一个范围，如果不是这样连着的，那么久表示三个简单的字符了\n\n\n\n# ^ 非\n[#abc]: 匹配字符串中的所有的字符，除了a,b,c这三个字符，这三个字符不一定连在一起\n\n\n常见情况\n- 字符串里面可能有空格，回车，我想去掉\n- 在字符串中查找字符串`abc`，如果存在，就都替换成`ABC`\n- 查找某个字符串中是否含有`abc`\n- 匹配数字\n- 匹配电话号码\n- 匹配邮箱\n- 确定字符串的大小是否在某个区间\n\n在姓名列表中，将王性别的都给去掉\n\n```\nvar str=`\n王兵\n韦杰\n赵某某\n钱某某\n王某某\n孙某某\n`;\n\nvar arr=str.split('\\n');\nconsole.log(arr);\nvar res=arr.filter(function(val,index,arr){\n   if( val.search(/^王/) >-1 ){\n        return false;\n   }else{\n       return true;\n   }\n}).join('\\n');\nconsole.log(arr);\nconsole.log(res);\n\n```\n\n我们也可以将这些反斜杠代码用在方括号中。例如，[\\d.]匹配任意数字或一个句号。但是方括号中的句号会失去其特殊含义。其他特殊字符也是如此，比如+。\n\n\n脱字符（^）\n\n\n分组是提取部分字符串的实用特性","categories":["JAVASCRIPT"]},{"title":"常用事件","url":"/2018/03/19/JAVASCRIPT/常用事件/","content":"\n## 鼠标事件\n- click\n- dblclick\n- mousemove\n- mouseover\n- mouseenter\n- mouseout\n- mouseleave\n- contextmenu\n\n\n## 键盘事件\n- keydown\n- keypress\n- keyup\n\n\n\n## 进度事件\n- \n\n\n## 拖拉事件\n- drag\n- dragstart\n- dragend\n- dragenter\n- dragover\n- dragleave\n- drop\n\n## 触摸事件\n- touchstart\n- touchend\n- touchmove\n- touchcancel\n\n\n## 表单事件\n- input\n- select\n- Change\n- reset,submit\n- \n- \n\n## 文档事件\n- \n- \n- \n- \n- \n- \n\n## 自定义事件和事件模拟\n- \n- \n- \n- \n- \n- \n\n","categories":["JAVASCRIPT"]},{"title":"日期常用方法","url":"/2018/03/19/JAVASCRIPT/日期常用方法/","content":"\n# 时间戳\n时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数，注意，是秒数\n\n## Date对象\n- Date():返回向前时间的实例对象\n- Date.now():毫秒时间戳\n- Date.parse():解析日期字符串，返回毫秒时间戳\n- Date.UTC(year, month[, date[, hrs[, min[, sec[, ms]]]]]) :根据传入的参数，生成UTC的毫秒时间戳，而date默认返回的是当前时区的时间戳\n\n\n如果你为Date构造器指定了一个参数，构造器会将该参数看成毫秒数。你可以创建一个新的Date对象，并调用getTime方法，或调用Date.now()函数来获取当前时间对应的毫秒数。\n\n\n\n\n\n## Date实例对象\n- new Date():生成当前时间的实例对象\n- new Date(milliseconds):生成指定毫秒时间戳的实例对象\n- new Date(datestring):生成指定字符串的实例对象\n- new Date(year, month [, day, hours, minutes, seconds, ms])生成指定参数的实例对象\n- Date.prototype.get系列方法\n- Date.prototype.set系列方法\n- Date.prototype.toString():将实例对象变成字符串\n- Date.prototype.toUTCString()，Date.prototype.toISOString():两者相等:返回的字符串是伦敦时间，世界标准时间\n- Date.prototype.toDateString()，Date.prototype.toTimeString():返回日期部分，不要时间的部分，**返回的结果是英文的，不方便阅读**，另一个正好相反\n- Date.prototype.toLocalString() ,Date.prototype.toLocalDateString()，Date.prototype.toLocalTimeString():**返回的结果是当地的写法，方便阅读**\n- Date.prototype.valueOf():返回毫秒时间戳，===getTime\n- Date.prototype.toJSON():没啥意义\n\n\n日期的计算\n- 相减：返回两个实例对象的好描述\n- 相加: 字符串拼接\n\n\n","categories":["JAVASCRIPT"]},{"title":"数组常用方法","url":"/2018/03/19/JAVASCRIPT/数组常用方法/","content":"\n## 数组常用方法\n- valueOf:数组本身\n- toString:变成数组，中间间隔的只能是逗号,=== arr.join()\n- push:尾部添加，返回添加后的新数组的长度\n- pop:删除最后一个，返回删除的元素\n- shift:删除投一个,返回删除的元素\n- unshift:头部添加一个，返回添加后新数组的长度\n- join:使用指定字符串拼接数组为一个字符串\n- contact:拼接数组\n- reverse:反转数组\n- splice:切割数组，返回切割出来的数组\n- slice:Returns a section of an array.\n- sort:数组排序\n\n\n\n\nECMAScript 5 新加入的数组方法\n- forEach:为数组中的每一个元素执行指定的方法\n- map:为数组中的每一个元素执行指定的方法，并且返回的结果会组成一个新的数组\n- filter:和map有什么区别\n- some,every: 确定是否数组中所有的元素都满足回调的的返回结果\n- reduce ,reduceRight:让数组中每个元素调用回调函数，回调函数的返回结果是累积的，并且这个累积的结果会当作参数传给下一个回调函数\n- indexOf,lastIndexOf\n\n\n\n\n## 能改变数组的方法\n- push,pop,shift,unshift\n- reverse\n- splice\n- sort\n\n## 不能改变数组的方法(纯函数)\n- contact\n- join\n- toString\n- forEach\n- map\n- some,every\n- reduce,reduceRight\n- indexOf,lastIndexOf\n\n\n\n\n## 数组增删方法例子\n比如，我想给自己列一个学习计划表，比如\n```\nlet task=[]\n```\n初步想法是先学习'html','css','js'这三个\n那么用代码表示就是:\n```\ntask.push('html','css','js');//3\nconsole.log(task);//'html','css','js'\n```\n好了，我要从头学起了，先学html\n```\ntask.shift();//html\nconsole.log(task);//css,js\n```\n学完html，下面就是css了\n\n```\ntask.shift();//css\nconsole.log(task);//js\n```\n最后就剩下js了，但是这个时候我突然想看node了，怎么做？\n```\ntask.unshift('node');//2\nconsole.log(task);//node,js\n```\n但是我这个时候发现，先看node不行，得先学习js\n```\ntask.pop();//js\nconsole.log(task);//node\n```\n\n\n\n# 方法分类，便于记忆\n\n数组的堆栈操作\npush,pop,unshift,shfit\n\n循环遍历\nmap,forEach,reduce,reducerRight\n\n查找/取出特定值\nfilter,some,every,indexOf,lastIndexOf,slice,splice\n\n排序\nsort \n\n变换\ntoString,concat,join,\n","categories":["JAVASCRIPT"]},{"title":"日期常用方法","url":"/2018/03/19/JAVASCRIPT/对象常用方法/","content":"\n","categories":["JAVASCRIPT"]},{"title":"宽度和高度","url":"/2018/03/19/JAVASCRIPT/宽度和高度/","content":"\n![flux](/images/width.jpg)\n\n#window\ninnerWidth/innerHeight:不包含顶部收藏栏等内容的高度，\nouterWidth/outerHeight:包含收藏栏的高度,\n宽度的话，略微不等，差值在window的两边的小细条，不包括滚动条，window的宽高和滚动条没关系\n\n#screen\nscreen.height:显示器的宽高，不会变化，\nscreen.width\nscreen.avaiHeight\nscreen.avaiWidth\nwindow.screenTop:window距离显示器顶部的高度\nwindow.screenLeft;\n\n#document\n- client:元素的可视部分宽高，即padding+content，如果没有滚动条，那么就是元素设定的宽度和高度\n- offset:content+padding+border\n- scroll:元素的内部元素\n\n## client\nwidth:padding+content,没有滚动条，就是元素的宽度，有的话，就是元素的宽度，减掉滚动条的宽度，滚动条宽度一般就是17px\nheight:减掉滚动条的高度\nmac系统中，滚动条是不占用宽度的，因为滚动条是悬浮的\nwindow系统中，会改变的\n\n\n\n该属性指的是元素的可视部分宽度和高度，即padding+content，如果没有滚动条，即为元素设定的高度和宽度，如果出现滚动条，滚动条会遮盖元素的宽高，那么该属性就是其本来宽高减去滚动条的宽高\n\n\n\nclientLeft:元素周围左边框的宽度\nclientTop:元素周围上边框的宽度\n\n## offset\n- width:content+padding+border,比client多了个border，这两个属性和该元素内部元素是否超出无关，只和设定的宽高有关\n- height\n\n\n\n- left:麻烦，和offsetParent相关，并且浏览器兼容还有问题\n- top:offsetParent\n\n### offsetParent\n- 如果没有定位，offsetParent就是body\n- 如果有定位，那么offsetParent就是就是最近的那个元素\n\n说到这对属性就需要说下offsetParent,所谓offsetParent指的是当前元素的离自己最近的具有定位的（position:absolute或者position：relative）父级元素（不仅仅指的是直接父级元素，只要是它的父元素都可以），该父级元素就是当前元素的offsetParent，如果从该元素向上寻找，找不到这样一个父级元素，那么当前元素的offsetParent就是body元素。而offsetLeft和offsetTop指的是当前元素，相对于其offsetParent左边距离和上边距离，即当前元素的border到包含它的offsetParent的border的距离\n\n\n## scroll\n- width\n- height\n- left\n- top\nbody.scroll 和div.scroll是有区别的\n\nbody.scrollWidth\n\n\nscrollHeight和scrollWidth\n\n顾名思义，这两个属性指的是当元素内部的内容超出其宽度和高度的时候，元素内部内容的实际宽度和高度，需要注意的是，当元素其中内容没有超过其高度或者宽度的时候，宽度或者高度就是该元素的高度或者宽度\n注意：当宽度超出的时候，出现滚动条，scrollHeight需要减掉滚动条\n\n\n\n# 可读可写属性\nscrollTop和scrollLeft\n指的是当元素其中的内容超出其宽高的时候，元素被卷起的高度和宽度。\n\n可以通过赋值内容自动滚动到某个位置\n\n设置这个值，感觉是可以展示元素的**内部**的特定部位\n\n>>> 如果元素设置了overflow:hidden,那么，设置再设置改元素的scrollTop=100，会怎么样？？？\n所有的子元素会整体网上移动100px，而不会出现滚动条，这个经常出现在某些特效上，并且，如果不设置overflow的话，反而不会出现滚动条，因为默认是超出就溢出的，这样的话，设置scrollTop就无效了，因为没有滚动条\n\n**想要设置这两个值，必须要有滚动条，或者overflow:hidden,否则无效**\n\n如果一个元素内部可以垂直滚动的距离是100px，我设置为800，会怎么样？\n内部的元素都跑到800的地方，不会，会跑到最大值的地方，也就是100px的地方\n\n#obj.style.*属性\n\n对于一个dom元素，它的style属性返回的是一个对象，这个对象中的任意一个属性是可读写的。如obj.style.top,obj.style.wdith等，在读的时候，他们返回的值常常是带有单位的(如px),同时，对于这种方式，\n\n它只能够获取到该元素的行内样式，而并不能获取到该元素最终计算好的样式，这就是在读取属性值得时候和以上只读属性的区别，要获取计算好的样式，请使用obj.currentstyle（IE）和getComputedStyle(IE之外的浏览器)。另一方面，这些属性能够被赋值，js运动的原理就是通过不断修改这些属性的值而达到其位置改变的，需要注意的是，给这些属性赋值的时候需要带单位的要带上单位，否则不生效。\n\n\n# Event对象\n对于元素的运动的操作通常都会涉及到event对象，而event对象也存在很多位置属性，且由于浏览器兼容性问题会导致这些属性间相互混淆，这里一一讲解。\n\n## clientX和clientY\n这对属性是当事件发生时，鼠标点击位置相对于浏览器（可视区）的坐标，即浏览器左上角坐标的（0,0），该属性以浏览器左上角坐标为原点，计算鼠标点击位置距离其左上角的位置，\n\n不管浏览器窗口大小如何变化，都不会影响点击位置的坐标。\n\n\n## screenX和screenY\n是事件发生时鼠标相对于屏幕的坐标，以设备屏幕的左上角为原点，事件发生时鼠标点击的地方即为该点的screenX和screenY值，如下所示：\n\n## offsetX和offsetY\n这一对属性是指当事件发生时，鼠标点击位置相对于该事件源的位置，即点击该div，以该div左上角为原点来计算鼠标点击位置的坐标\n\n## pageX和pageY\n\n顾名思义，该属性是事件发生时鼠标点击位置相对于页面的位置，通常浏览器窗口没有出现滚动条时，该属性和event.clientX及event.clientY是等价的，但是当浏览器出现滚动条的时候，pageX通常会大于clientX，因为页面还存在被卷起来的部分的宽度和高度\n\n\n\n\n\n------------------------------\n- window\n    - innerWidth/innerHeight\n    - outerWidth/outerHeight\n    - screenTop/screenLeft\n- screen\n    - width/height\n- document\n    - client\n        - width/height:可视区域的宽高\n        - top/left:边框的宽高\n    - offset\n        - left/top:距离offsetParent的距离\n        - width/height:元素的宽高\n    - scroll\n        - left/top:内部元素滚动的距离\n        - width/height:内部元素的宽高\n- event\n    - clientX/clientY:浏览器\n    - screenX/screenY\n    - offsetX/offsetY:事件源\n    - pageX/pageY\n\n------------------------\n# 可读写属性\n- scrollTop/scrollLeft:只能是正数\n- div.style.*\n\n\n\n\n#getBoundingClientRect()\n\n这个方法返回一个矩形对象，包含四个属性：left、top、right和bottom。分别表示元素各边与页面上边和左边的距离。\n\n\n\n\n# 常用案例\n- 可视区域加载动画\n- 滚动到底部加载\n- 回到顶部\n\n\n# 常见问题\n- 如何获得页面的滚动距离\n    document.documentElement.scrollTop\n- 如果一个元素没有设置宽高，怎么得到他的实际宽高呢？？？？\n    div.clientHeight\n- 如何得到一个元素到body的距离\n- \n    \n\n\n\n# 放大镜案例\n\n\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n\n</head>\n\n<body>\n\n    <div class=\"small_box\">\n        <div class=\"mouse_box\"></div>\n        <img class=\"small\" src=\"./macbook-small.jpg\" alt=\"\">\n    </div>\n\n    <div class=\"big_box\">\n        <img class=\"big\" src=\"./macbook-big.jpg\" alt=\"\">\n    </div>\n\n\n\n</body>\n\n</html>\n\n<style>\n    * {\n        margin: 0;\n        padding: 0;\n    }\n\n    .small_box {\n        border: 1px solid #aaa;\n        position: relative;\n        display: inline-block;\n        margin: 20px;\n        /* width: 400px; */\n        /* height: 400px; */\n    }\n\n    img.small {}\n\n    .mouse_box {\n        /* display: none; */\n        position: absolute;\n        left: 20px;\n        top: 20px;\n        height: 100px;\n        width: 100px;\n        background-color: rgba(253, 208, 9, 0.5);\n        cursor: move;\n    }\n\n    .mouse_box {}\n\n    .big_box {\n        /* display: none; */\n        border: 1px solid #bbb;\n        position: fixed;\n        right:10%;\n        top: 10%;\n        width: 400px;\n        height: 400px;\n        overflow: auto;\n        overflow: hidden;\n    }\n\n    img.big {}\n</style>\n<script src=\"jquery.js\"></script>\n<script>\n    var small_box = document.querySelector('.small_box');\n    var small = document.querySelector('img.small');\n    var big = document.querySelector('img.big');\n    var mouse_box = document.querySelector('.mouse_box');\n    var big_box = document.querySelector('.big_box');\n    // \n    var rate=big.offsetWidth/small.offsetWidth;\n\n    small_box.onmouseover = function (ev) {\n        ev.stopPropagation();\n        \n        mouse_box.style.display = 'block';\n        small_box.onmousemove = function (ev) {\n            // console.log(ev.target);\n            var left_val=ev.clientX -small_box.offsetLeft- mouse_box.offsetWidth/2;\n            var top_val=ev.clientY - small_box.offsetTop-mouse_box.offsetHeight/2;\n            if(left_val < 0){\n                left_val=0;\n            }else if(left_val > small_box.offsetWidth-mouse_box.offsetWidth){\n                left_val = small_box.offsetWidth-mouse_box.offsetWidth\n            }\n            if(top_val<0){\n                top_val=0;\n            }else if(top_val > small_box.offsetHeight-mouse_box.offsetHeight){\n                top_val = small_box.offsetHeight-mouse_box.offsetHeight\n            }\n            mouse_box.style.left = left_val + 'px';\n            mouse_box.style.top = top_val + 'px';\n            //大窗口图片的移动\n            // left_val/small_box.offsetWidth == xxx/big.offsetWidth\n            //xxx===\n            big_box.scrollLeft=left_val*rate;\n            big_box.scrollTop=top_val*rate;\n            // big_box.scrollTop=top_val*rate;\n\n           \n\n        }\n        return false;\n    }\n    small_box.onmouseout = function () {\n        mouse_box.style.display = 'none';\n        small_box.onmousemove = null;\n    }\n\n   \n</script>\n```\n\n# 滚动到底部自动加载\n```\n\nconsole.log('main.js....')\nimport '../styles/main.scss';\nfunction getData(callback) {\n    var xhr = new XMLHttpRequest();\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4) {\n            var res = JSON.parse(xhr.responseText);\n            var list = JSON.parse(res.data).result.data;\n            callback(list);\n        }\n    }\n    xhr.open('GET', 'http://www.test.com/news.php');\n    xhr.send();\n}\n\nfunction render(list) {\n    var html = '';\n    list.forEach(val => {\n        html += `\n                <li class=\"list-group-item\">\n                    <a target='_blank' href=\"${val.url}\">\n                        <div class=\"img-box\">\n                            <img class=\"img-responsive\" src=\"${val.thumbnail_pic_s}\">\n                        </div>\n                        <p class=\"title\">${val.title}</p>\n                    </a>\n                </li>`;\n    });\n    var listGrout=document.querySelector('.list-group');\n    listGrout.innerHTML += html;\n};\n\ngetData(render);\n//上滑加载\ndocument.body.onscroll=function(){\n    if(document.documentElement.scrollTop+document.documentElement.clientHeight >= document.body.clientHeight){\n        console.log(11111);\n        getData(render);\n    }\n}\n\n\n```","categories":["JAVASCRIPT"]},{"title":"[],{} 视为true","url":"/2018/03/19/JAVASCRIPT/布尔值/","content":"只有这几种情况视为false，其他都为true，包括[],{}\n- undefined\n- null\n- false\n- 0\n- NaN\n- \"\"（空字符串）","categories":["JAVASCRIPT"]},{"title":"尺寸和位置","url":"/2018/03/19/JAVASCRIPT/尺寸和位置/","content":"\n尺寸:","categories":["JAVASCRIPT"]},{"title":"得到时间戳","url":"/2018/03/19/JAVASCRIPT/如何得到时间戳/","content":"\n\n\n当前时间的时间戳\n\n```\nvar timeStamp=Date.now();//now方法返回当前距离1970年1月1日 00:00:00 UTC的毫秒数\n```\n\n得到指定时间的时间戳(格式:YYYY-MM-DDTHH:mm:ss.sssZ)\n\n```\nvar timeStamp=Date.parse(\"January 26, 2011 13:51:50\");\n```\n\n\n\n时间戳转换成时间对象\n\n```\nvar date=new Date(1508159604*1000);\nvar res=date.getHours();\nconsole.log(res);\n\n```\n\n\n\n\n\n\n\n","categories":["JAVASCRIPT"]},{"title":"字符串常用方法","url":"/2018/03/19/JAVASCRIPT/字符串常用方法/","content":"\n数组常用方法\n- length属性\n- charAt\n- charCodeAt\n- concat:拼接字符串(基本用不到)\n- slice:截取字符串\n- substring：截取字符串\n- substr：截取字符串\n- indexOf,lastIndexOf:按照索引查字符\n- trim:原字符串不改变\n- toUpperCase,toLowerCase:原字符串不改变\n- match:匹配字符串  (查找字符串中出现次数最多的字符)返回查找到的数组\n- search：查找字符串     返回查找到的索引\n- replace：替换字符串    返回替换后的结果，原字符串不改变\n- split:原字符串不改变\n\n## 以上的函数，都不会改变本身字符串\n\n```\nconsole.log(str.match(/G/g));//返回查找到的数组\nconsole.log(str.search(/a/g));//返回查找到的索引\nconsole.log(str.replace(/G/g,'g'));//返回替换后的结果，原字符串不改变\n```\n\n\n# 数组公用方法\nconcat,indexOf  ","categories":["JAVASCRIPT"]},{"title":"如何保留小数点后2位.md","url":"/2018/03/19/JAVASCRIPT/如何保留小数点后2位/","content":"\n# Number.prototype.toFixed()\n\n","categories":["QUESTION"]},{"title":"原生接口写个小东西","url":"/2018/03/19/JAVASCRIPT/原生接口写个小东西/","content":"\n## 写个swiper\n## 写个tab\n```\n<ul class=\"tabs\">\n    <li >tab1</li>\n    <li>tab2</li>\n    <li>tab3</li>\n</ul>\n<ul class=\"tab-contents\">\n    <li>tab1tab1tab1tab1</li>\n    <li>tab2tab2tab2tab2</li>\n    <li>tab3tab3tab3tab3</li>\n</ul>\n```\n```\nvar tabs=document.getElementsByClassName('tabs')[0].getElementsByTagName('li');\nvar tabContents=document.getElementsByClassName('tab-contents')[0].getElementsByTagName('li');\n\n// init\nvar index=0;\ntabs[0].className+=\"active\";\ntabContents[0].className+=\"active\";\n\nfor(var i=0;i<tabs.length;i++){\n    tabs[i].dataset.id=i;\n    tabs[i].addEventListener('click',function(ev){\n        console.log(this.dataset.id);\n        //清空tabs，tab-contents中li的active\n        for(var i=0;i<tabs.length;i++){\n            tabs[i].className=tabs[i].className.replace(/active/g,'');\n        }\n        for(var i=0;i<tabContents.length;i++){\n            tabContents[i].className=tabContents[i].className.replace(/active/g,'');\n        }\n        this.className+='active';\n        tabContents[this.dataset.id].className+='active';\n    });\n}\n```\n## 写个模态框\n\n## html\n```\n  <button id=\"btn1\" data-target='#modal1' data-toggle='modal'>btn1</button>\n  <button id=\"btn1\" data-target='#modal2' data-toggle='modal'>btn1</button>\n\n\n    <div class=\"modal\" id=\"modal1\">\n      <div class=\"modal-content\">\n          <div class=\"modal-header\">标题</div>\n          <div class=\"modal-body\">内容</div>\n          <div class=\"modal-footer\">footer</div>\n      </div>\n    </div>\n\n```\n## scss\n\n```\n\n@keyframes am1{\n    from{\n        top: -100%;\n    }\n    to{\n        top: 50%;\n    }\n}\n\n.modal{\n    position: fixed;\n    left: 0%;\n    top: 0%;\n    width: 0;\n    height: 0;\n    opacity: 0;\n    overflow: hidden;\n    transition: opacity 1s;\n    background-color: rgba(0,0,0,0.3);\n    &.active{\n        opacity: 1;\n        width: 100%;\n        height: 100%;\n        .modal-content{\n            animation: 1s am1;\n        }\n    }\n    \n    .modal-content{\n        width: 500px;\n        height: 400px;\n        position: relative;\n        left: 50%;\n        top: 50%;\n        background-color: #fff;\n        transform: translate(-50%,-50%);\n    }\n}\n\n\n```\njs\n\n```\nvar modal_btns=document.querySelectorAll('[data-toggle=\"modal\"]');\nfor(var i=0;i<modal_btns.length;i++){\n    modal_btns[i].addEventListener('click',function(ev){\n        //淡入淡出的效果\n        var target=document.querySelector(this.dataset.target);\n        if(target){\n            target.classList.toggle('active');\n            // target.className= target.className.search(/active/) >-1 ? target.className.replace(/active/,'') : target.className+' active';\n        }\n    });\n}\n\n\nvar modals=document.querySelectorAll('.modal');\nfor(var i=0;i<modals.length;i++){\n    modals[i].addEventListener('click',function(ev){\n        console.log(ev.target.classList);\n        if( !ev.target.classList.contains('modal')  ){\n            return false;//防止误操作\n        }\n        // this.className=this.className.replace(/active/,'');\n        target.classList.toggle('active');\n    })\n}\n\n\n\n```\n\n## 写个下拉菜单\n## 写个tooltip\n## 写个警告框\n## Collapse \n\n","categories":["JAVASCRIPT"]},{"title":"区块","url":"/2018/03/19/JAVASCRIPT/区块/","content":"\n使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。\n\n","categories":["JAVASCRIPT"]},{"title":"变量提升","url":"/2018/03/19/JAVASCRIPT/变量提升/","content":"\n\nJavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。","categories":["JAVASCRIPT"]},{"title":"切换/固定this","url":"/2018/03/19/JAVASCRIPT/切换固定this/","content":"\n切换/固定this\n- call:`func.call(thisValue, arg1, arg2, ...)`\n- apply:`unc.apply(thisValue, [arg1, arg2, ...])`\n- bind:`func.bind(thisValue, arg1, arg2,...)`\n\n\n> call方法的一个应用是调用对象的原生方法,示例:\n```\n???\n```\n\n","categories":["JAVASCRIPT"]},{"title":"伪百度","url":"/2018/03/19/JAVASCRIPT/伪百度/","content":"\n我希望的达到如下的效果\n打开一个网页后，进行任何操作，如果用户点击浏览器的后退操作，我希望跳转到百度页面\n","categories":["JAVASCRIPT"]},{"title":"什么是语句，什么是表达式","url":"/2018/03/19/JAVASCRIPT/什么是语句，什么是表达式/","content":"\n\n语句（statement）是为了完成某种任务而进行的操作，以分号结尾\n\n表达式（expression）:指一个为了得到返回值的计算式，不需要分号结尾\n\n区别：表达式有一个返回值\n\n```\nvar a = 1 + 3;\n//这条代码，是一个语句，赋值语句\n//1+3这个是一个表达式，是一个计算式；\n```\n\n","categories":["JAVASCRIPT"]},{"title":"事件","url":"/2018/03/19/JAVASCRIPT/事件/","content":"\n\nDOM的事件操作（监听和触发），都定义在EventTarget接口\n该接口就是三个方法，addEventListener和removeEventListener用于绑定和移除监听函数，dispatchEvent用于触发事件。\n\n\n\n# addEventListener\n 为当前对象的同一个事件，添加多个监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用removeEventListener方法手动去除）。\n\n\n 如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数。\n```\nfunction print(x) {\n  console.log(x);\n}\n\nvar el = document.getElementById(\"div1\");\nel.addEventListener(\"click\", function(){print('Hello')}, false);\n```\n\n\n\n\n# 监听函数\n\n- HTML标签的on-属性\n\n使用这种方法时，on-属性的值是“监听代码”，而不是“监听函数”。也就是说，一旦指定事件发生，这些代码是原样传入JavaScript引擎执行。因此如果要执行函数，必须在函数名后面加上一对圆括号。\n\n\n- Element节点的事件属性\n\n**同一个事件只能定义一个监听函数**\n\n- addEventListener方法\n\n\n\n# 事件的传播\n\n传播的三个阶段\n- 第一阶段：从window对象传导到目标节点，称为“捕获阶段”（capture phase）。\n- 第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。\n- 第三阶段：从目标节点传导回window对象，称为“冒泡阶段”（bubbling phase）。\n\n事件的代理\n由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。\n\n","categories":["JAVASCRIPT"]},{"title":"mouseover && mouseenter","url":"/2018/03/19/JAVASCRIPT/mouseover && mouseenter/","content":"\nmouseover && mouseenter\n\nmouseover事件和mouseenter事件，都是鼠标进入一个节点时触发。\n\n两者的区别是，mouseover事件会冒泡，mouseenter事件不会\n\n```\n// HTML代码为\n// <ul id=\"test\">\n//   <li>item 1</li>\n//   <li>item 2</li>\n//   <li>item 3</li>\n// </ul>\n\nvar test = document.getElementById(\"test\");\n\n// 进入test节点以后，该事件只会触发一次\ntest.addEventListener(\"mouseenter\", function( event ) {\n  event.target.style.color = \"purple\";\n  setTimeout(function() {\n    event.target.style.color = \"\";\n  }, 500);\n}, false);\n\n// 接入test节点以后，只要在子Element节点上移动，该事件会触发多次\ntest.addEventListener(\"mouseover\", function( event ) {\n  event.target.style.color = \"orange\";\n  setTimeout(function() {\n    event.target.style.color = \"\";\n  }, 500);\n}, false);\n```\n","categories":["JAVASCRIPT"]},{"title":"严格模式","url":"/2018/03/19/JAVASCRIPT/严格模式/","content":"\nstrict模式\n- 开头使用 `'use strict';`\n- 变量都必须先用var命令声明，然后再使用(没有默认全局变量了)\n- eval函数创建的变量属于eval自己的作用域，外部无法获得，但是eval依然可以修改外部变量，\n- 禁止this指向全局变量\n- 禁止删除变量\n- 显式报错\n- arguments对象的限制\n\n\n# 严格模式下也有变量提升\n\n\n","categories":["JAVASCRIPT"]},{"title":"typeof && instanceof","url":"/2018/03/19/JAVASCRIPT/typeof && instanceof/","content":"\n既然typeof对数组（array）和对象（object）的显示结果都是object，那么怎么区分它们呢？instanceof运算符可以做到。\n\n```\nvar o = {};\nvar a = [];\n\no instanceof Array // false\na instanceof Array // true\n```","categories":["JAVASCRIPT"]},{"title":"promise","url":"/2018/03/19/JAVASCRIPT/promise/","content":"\nes5中先执行a，再执行b，方法只有两个，回掉，事件\nes6中有promise\n\n**promise 每一步都要返回一个promise对象，不然没法then**\n\n** then里面的函数，是什么，是回调函数**\n\n# 它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以采用同步操作的流程。这个Promises对象有一个then方法，允许指定回调函数，在异步任务完成后调用\n\n所以，PROMISE(承诺)的到底是什么东西？？？？承诺的就是你给我传入的resolve给我放到then中，我调用resolve执行的时候，就取你放入then的方法\n\n起始一个promise只会有一个then，但是每个then都返回promise，那么就可以连接起来使用了\n\n\n\n## 有这样一个需求，页面中有一个模拟客服发消息的对话框，第一秒出来第一句话，你好，第二秒出来一句话，在吗，第三秒出来一句话，欢迎，怎么用js实现这个效果,如果有更多句话，怎么做方便使用\n\n```\n\nvar words = ['你好', '在吗', '欢迎'];\nvar i = 0;\n\nfunction say() {//回掉\n    console.log(words[i]);\n    i++;\n    setTimeout(function() {\n        console.log(words[i]);\n        i++;\n        setTimeout(function() {\n            console.log(words[i]);\n            i++;\n        }, 1000);\n    }, 1000);\n}\nsay();\n```\n\n## promise\n\n```\nvar words = ['你好', '在吗', '欢迎'];\nvar i = 0;\n\nfunction say() {\n    console.log(words[i]);\n    i++;\n    return new Promise(function(resolve, refuse) {\n        setTimeout(function() {\n            resolve();\n        }, 1000);\n    });\n}\nsay()\n    .then(function() {\n        console.log(words[i]);\n        i++;\n        return new Promise(function(resolve, refuse) {\n            setTimeout(function() {\n                resolve();\n            }, 1000);\n        });\n    })\n    .then(function() {\n        console.log(words[i]);\n        i++;\n        return new Promise(function(resolve, refuse) {\n            setTimeout(function() {\n                resolve();\n            }, 1000);\n        });\n    })\n```\n\n# async\n```\nfunction word(val,t){\n  return new Promise(function(resolve,reject){\n    setTimeout(function(){\n      console.log(val);\n      resolve();\n    },t)\n  })\n  console.log(val);\n}\n\nvar say= async function(){\n  await word('hello',3000);\n  await word('您好',3000);\n  await word('byebye',3000);\n}\nsay();\n\n```\n最简单，最直观，最方便","categories":["JAVASCRIPT"]},{"title":"promise","url":"/2018/03/19/JAVASCRIPT/promise.1/","content":"\nes5中先执行a，再执行b，方法只有两个，回掉，事件\nes6中有promise\n\n**promise 每一步都要返回一个promise对象，不然没法then**\n\n** then里面的函数，是什么，是回调函数**\n\n# 它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以采用同步操作的流程。这个Promises对象有一个then方法，允许指定回调函数，在异步任务完成后调用\n\n所以，PROMISE(承诺)的到底是什么东西？？？？承诺的就是你给我传入的resolve给我放到then中，我调用resolve执行的时候，就取你放入then的方法\n\n起始一个promise只会有一个then，但是每个then都返回promise，那么就可以连接起来使用了\n\n\n\n## 有这样一个需求，页面中有一个模拟客服发消息的对话框，第一秒出来第一句话，你好，第二秒出来一句话，在吗，第三秒出来一句话，欢迎，怎么用js实现这个效果,如果有更多句话，怎么做方便使用\n\n```\n\nvar words = ['你好', '在吗', '欢迎'];\nvar i = 0;\n\nfunction say() {//回掉\n    console.log(words[i]);\n    i++;\n    setTimeout(function() {\n        console.log(words[i]);\n        i++;\n        setTimeout(function() {\n            console.log(words[i]);\n            i++;\n        }, 1000);\n    }, 1000);\n}\nsay();\n```\n\n## promise\n\n```\nvar words = ['你好', '在吗', '欢迎'];\nvar i = 0;\n\nfunction say() {\n    console.log(words[i]);\n    i++;\n    return new Promise(function(resolve, refuse) {\n        setTimeout(function() {\n            resolve();\n        }, 1000);\n    });\n}\nsay()\n    .then(function() {\n        console.log(words[i]);\n        i++;\n        return new Promise(function(resolve, refuse) {\n            setTimeout(function() {\n                resolve();\n            }, 1000);\n        });\n    })\n    .then(function() {\n        console.log(words[i]);\n        i++;\n        return new Promise(function(resolve, refuse) {\n            setTimeout(function() {\n                resolve();\n            }, 1000);\n        });\n    })\n```","categories":["JAVASCRIPT"]},{"title":"in运算符","url":"/2018/03/19/JAVASCRIPT/in运算符/","content":"\n> in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。\n\n```\nvar o = { p: 1 };\n'p' in o // true\n```\n该运算符对数组也适用。\n\n```\nvar a = [\"hello\", \"world\"];\n\n0 in a // true\n1 in a // true\n2 in a // false\n\n'0' in a // true\n'1' in a // true\n'2' in a // false\n```\n\nin运算符的一个问题是，它不能识别对象继承的属性。\n```\nvar o = new Object();\no.hasOwnProperty('toString') // false\n\n'toString' in o // true\n```\n上面代码中，toString方法不是对象o自身的属性，而是继承的属性，hasOwnProperty方法可以说明这一点。但是，in运算符不能识别，对继承的属性也返回true。\n\n\n\n\nfor...in循环用来遍历一个对象的全部属性。\n\n```\nvar o = {a:1, b:2, c:3};\n\nfor (i in o){\n  console.log(o[i]);\n}\n// 1\n// 2\n// 3\n```\n注意，for...in循环遍历的是对象所有可enumberable的属性，其中不仅包括定义在对象本身的属性，还包括对象继承的属性。","categories":["JAVASCRIPT"]},{"title":"js脚本执行顺序","url":"/2018/03/19/JAVASCRIPT/js脚本执行顺序/","content":"\n","categories":["JAVASCRIPT"]},{"title":"genertor","url":"/2018/03/19/JAVASCRIPT/genertor/","content":"\n# 什么是genertor?\n# 怎么用？\n# 有什么用？\n\n\n\n\n\n\n\n## 有这样一个需求，页面中有一个模拟客服发消息的对话框，第一秒出来第一句话，你好，第二秒出来一句话，在吗，第三秒出来一句话，欢迎，怎么用js实现这个效果,如果有更多句话，怎么做方便使用\n\n\n```\nvar words = ['你好', '在吗', '欢迎', '请问您有什么需要'];\nvar i = 0;\n\nfunction say(t) {\n    setTimeout(function() {\n        console.log(words[i]);\n        i++;\n    }, t);\n}\n\nvar g = function*() {\n    yield say(1000);\n    yield say(2000);\n    yield say(3000);\n    yield say(4000);\n}\n\nvar res = g();\nres.next();\nres.next();\nres.next();\nres.next();\n```\n\n","categories":["JAVASCRIPT"]},{"title":"history","url":"/2018/03/19/JAVASCRIPT/history/","content":"\n\n# history 基本方法\n- back()：移动到上一个访问页面，等同于浏览器的后退键。\n- forward()：移动到下一个访问页面，等同于浏览器的前进键。\n- go()：接受一个整数作为参数，移动到该整数指定的页面，比如go(1)相当于forward()，go(-1)相当于back()。history.go(0)相当于刷新页面\n\n这三个方法可以实现基本的页面来回跳转，但是，不能实现的功能是打开一个新页面，只能通过点击a链接来实现\n# 新加方法\n- history.pushState()，浏览记录中添加该记录，执行后，并不会导致页面跳转到指定的页面\n- history.replaceState()\n\n# 无法跳转页面，怎么无刷新跳转页面\n这其实是一个误解，不是跳转到一个新的页面，而是所有的‘页面’都在同一个页面，点击这个页面的连接后，要做的就是两件事\n1，通过history.pushState()修改url，但是页面不会跳转，然后，通过ajax来获取指定的地址要呈现的数据，将这些数据，通过js加载到页面的指定地方，这样就可以实现了页面无刷新跳转，\n\n\n# 怎么SEO?????\n","categories":["JAVASCRIPT"]},{"title":"let const","url":"/2018/03/19/JAVASCRIPT/let/","content":"\nlet 和var的区别：块级作用域\n\nconst 也有作用域，这一点很不一样\n```\nif (1) {\n    const a = 111;\n}\n\nif (2) {\n    const a = 2222;//这样是正确的\n}\n```\n","categories":["JAVASCRIPT"]},{"title":"mouseout && mouseleave","url":"/2018/03/19/JAVASCRIPT/mouseout && mouseleave/","content":"\nmouseout事件和mouseleave事件，都是鼠标离开一个节点时触发。\n\n两者的区别是，mouseout事件会冒泡，mouseleave事件不会\n\n# 阻止冒泡\n\n```\nevent.stopPropagation();\n```","categories":["JAVASCRIPT"]},{"title":"fetch","url":"/2018/03/19/JAVASCRIPT/fetch/","content":"\n\n# 一种新规范，用来取代XMLHttpRequest对象,特点\n- 简化接口，将API分散在几个不同的对象上\n- 返回Promise对象，避免了嵌套的回调函数\n\n\n\n\n\n","categories":["JAVASCRIPT"]},{"title":"dataset属性","url":"/2018/03/19/JAVASCRIPT/dataset/","content":"\n## dataset属性用于操作HTML标签元素的data-*属性\n\n```\n<div id=\"myDiv\" data-id=\"myId\"></div>\n\nvar id = document.getElementById(\"myDiv\").dataset.id;\n```","categories":["JAVASCRIPT"]},{"title":"document","url":"/2018/03/19/HTML/document/","content":"\n## document\n\ndocument节点是文档的根节点\n\n属性：\n- doctype\n- documentElement ：**得到的就是html标签**\n- body :**得到的就是body标签**\n- head\n- URL\n- domain\n- location\n- title\n- anchors，embeds，forms，images，links，scripts，styleSheets\n- cookie\n\n\n方法：\n- open()，close()，write()，writeln()\n- querySelector()，getElementById()，querySelectorAll()，getElementsByTagName()，getElementsByClassName()，getElementsByName()\n- createElement()，createTextNode()，createAttribute()，\n- addEventListener()，removeEventListener()，dispatchEvent()\n\n\n# write()，writeln()区别\n\nwriteln()的效果，最后有一个换行\n![writeln](/images/img1.png)\n-------------\nwrite()的效果，没有换行\n![write](/images/img2.png)\n\n\n\n\n\n\n\n\n","categories":["HTML"]},{"title":"css操作","url":"/2018/03/19/JAVASCRIPT/css操作/","content":"\n","categories":["JAVASCRIPT"]},{"title":"element","url":"/2018/03/19/JAVASCRIPT/element/","content":"\n\n# 属性\n- attributes，id，tagName\n- innerHTML，outerHTML\n- children，childElementCount，firstElementChild，lastElementChild\n- nextElementSibling，previousElementSibling\n- className，classList\n- clientHeight，clientLeft，clientTop，clientWidth\n- scrollHeight，scrollWidth，scrollLeft，scrollTop\n\n# 方法\n- hasAttribute()，getAttribute()，removeAttribute()，setAttribute()\n- querySelector()，querySelectorAll()，getElementsByClassName()，getElementsByTagName()\n- closest()，matches()\n- addEventListener()，removeEventListener()，dispatchEvent()\n- getBoundingClientRect()，getClientRects()\n- insertAdjacentHTML()，remove()\n- scrollIntoView()\n\n","categories":["JAVASCRIPT"]},{"title":"跳出多层循环 break语句和continue语句","url":"/2018/03/19/JAVASCRIPT/break语句和continue语句/","content":"\nJavaScript语言允许，语句的前面有标签（label）。标签通常与break语句和continue语句配合使用，跳出特定的循环。\n\n```\ntop:\n    for (var i=0;i<3;i++){\n        for (var j=0;j<3;j++){\n            if (i===1 && j===1) break top;\n            console.log(\"i=\"+i+\",j=\"+j);\n        }\n}\n// i=0,j=0\n// i=0,j=1\n// i=0,j=2\n// i=1,j=0\n```\n上面代码为一个双重循环区块，加上了top标签（注意，top不用加引号）。当满足一定条件时，使用break语句加上标签名，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。\n\ncontinue语句也可以与标签配合使用。\n```\ntop:\n    for (var i=0;i<3;i++){\n        for (var j=0;j<3;j++){\n            if (i===1 && j===1) continue top;\n            console.log(\"i=\"+i+\",j=\"+j);\n        }\n}\n// i=0,j=0\n// i=0,j=1\n// i=0,j=2\n// i=1,j=0\n// i=2,j=0\n// i=2,j=1\n// i=2,j=2\n```\n上面代码在满足一定条件时，使用continue语句加上标签名，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。","categories":["JAVASCRIPT"]},{"title":"cookie","url":"/2018/03/19/JAVASCRIPT/cookie/","content":"\n\n如果cookie过期了，就跳转到登陆页面，否则跳转到欢迎页面,怎么实现？？？\n\n```\nvar expire=new Date(Date.now()+5000);\ndocument.cookie='is_login=true; expires='+expire.toGMTString();\nconsole.log(document.cookie);\n\n```\n\n需要注意的是\n- cookie格式 `value[; expires=date][; domain=domain][; path=path][; secure]`\n- expires: 日期格式等同于Date.toUTCString()的格式\n\n","categories":["JAVASCRIPT"]},{"title":"Math.max && Math.min","url":"/2018/03/19/JAVASCRIPT/Math.max && Math.min/","content":"\n# 求最大值和最小值，很有用","categories":["JAVASCRIPT"]},{"title":"classList","url":"/2018/03/19/JAVASCRIPT/classList/","content":"\n\n# 在元素className的时候，有很多问题，比如判断是否包含的时候\n\n```\nele.className.indexOf('modal') >-1//这样的判断是不保险的，比如含有 modal-content的话，就不行了\n```\n\n## classList对象有下列方法。\n- add()：增加一个class。\n- remove()：移除一个class。\n- contains()：检查当前元素是否包含某个class。 (非常有用)\n- toggle()：将某个class移入或移出当前元素。 (非常有用)\n- item()：返回指定索引位置的class。\n- toString()：将class的列表转为字符串。\n\n```\ndocument.getElementById('foo').classList.add('bold');\n```","categories":["JAVASCRIPT"]},{"title":"Node节点","url":"/2018/03/19/JAVASCRIPT/Node节点/","content":"\n## 类型\n- Document :文档节点\t整个文档（window.document）\n- DocumentType :文档类型节点\t文档的类型（比如）\n- Element:元素节点\tHTML元素（比如、等）\n- Attribute:属性节点\tHTML元素的属性（比如class=\"right\"）\n- Text:文本节点\tHTML文档中出现的文本\n- DocumentFragment:文档碎片节点\t文档的片段\n\n## 属性\n- nodeName\n- nodeType\n- ownerDocument\n- nextSibling\n- previousSibling\n- parentNode\n- parentElement\n- textContent\n- nodeValue\n- childNodes\n- firstNode\n- lastChild\n\n## 方法\n- appendChild\n- hasChildNodes\n- cloneNode\n- insertBefore:也是内部插入，因为带insert\n- removeChild\n- replaceChild\n\n\n节点对象都是单个节点，但是有时会需要一种数据结构，能够容纳多个节点。DOM提供两种接口，用于部署这种节点的集合：NodeList接口和HTMLCollection接口。\n\n## NodeList接口\n> 得到NodeList接口的方法\n- Node.childNodes\n- document.querySelectorAll\n\n\t\n## HTMLCollection接口\n>HTMLCollection接口与NodeList接口类似，也是节点的集合，但是集合成员都是Element节点。该接口都是动态集合，节点的变化会实时反映在集合中。document.links、docuement.forms、document.images等属性，返回的都是HTMLCollection接口对象。\n\n\n## ParentNode接口，ChildNode接口\n\n不同的节点除了继承Node接口以外，还会继承其他接口。ParentNode接口用于获取当前节点的Element子节点，ChildNode接口用于处理当前节点的子节点（包含但不限于Element子节点）。\n\n## ParentNode接口\nParentNode接口用于获取Element子节点。Element节点、Document节点和DocumentFragment节点，部署了ParentNode接口。凡是这三类节点，都具有以下四个属性，用于获取Element子节点\n\n- children\n- firstElementChild\n- lastElementChild\n- childElementCount\n\n## ChildNode接口\n- remove()\n\n\n","categories":["JAVASCRIPT"]},{"title":"ajax","url":"/2018/03/19/JAVASCRIPT/ajax/","content":"\n\n```\n// 新建一个XMLHttpRequest实例对象\nvar xhr = new XMLHttpRequest();\n\n// 指定通信过程中状态改变时的回调函数\nxhr.onreadystatechange = function(){\n\n    // 通信成功时，状态值为4\n    var completed = 4;\n    if(xhr.readyState === completed){\n        if(xhr.status === 200){\n            // 处理服务器发送过来的数据\n        }else{\n            // 处理错误\n        }\n    }\n};\n\n// open方式用于指定HTTP动词、请求的网址、是否异步\nxhr.open('GET', '/endpoint', true);\n\n// 发送HTTP请求\nxhr.send(null);\n```","categories":["JAVASCRIPT"]},{"title":"Object.assign","url":"/2018/03/19/JAVASCRIPT/Object.assign/","content":"\n#对象的复制，需要用到这个东西\n用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。\n语法：Object.assign(target, ...sources)，返回值是组合后的目标对象\n```\nvar obj1={\n    username:'wang'\n};\nvar obj2=Object.assign({},obj1,{sex:\"nan\"});\n```\n\n\n\n","categories":["JAVASCRIPT"]},{"title":"D3.js","url":"/2018/03/19/JAVASCRIPT/D3.js/","content":"\n","categories":["JAVASCRIPT"]},{"title":"默认值","url":"/2018/03/19/ES6/默认值/","content":"\n在 es5中，默认值是不存在的，在es6中却很多地方都存在\n\n# 解构赋值\n\n```\nlet [a,b=1]=[2];\nconsole.log(a,b);\n```\n\n# 函数参数\n\n```\nfunction test(a=1,b){\n  console.log(a,b);\n}\ntest();\n```","categories":["ES6"]},{"title":"Image对象","url":"/2018/03/19/JAVASCRIPT/Image对象/","content":"\n\n\n```\nvar img1=new Image('/var/1.jpg');\ndocument.appendChild(img1);\n\n```","categories":["JAVASCRIPT"]},{"title":"Error对象","url":"/2018/03/19/JAVASCRIPT/Error对象/","content":"\n# Error对象\n## Error对象的实例有三个最基本的属性：\n- name：错误名称\n- message：错误提示信息\n- stack：错误的堆栈（非标准属性，但是大多数平台支持）\n\n# 常见JavaScript的原生错误类型\n- SyntaxError:语法错误\n- ReferenceError:引用错误，由于引用了一个不存在的变量时候发生的错误\n- TypeError:类型错误,变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。\n\n# 自定义错误\n\n# finally代码块\n\n**不管是否出现错误，都必需在最后运行的语句。**\n\n# try...catch(e){}\n```\ntry{\n  throw new Error('报错了');\n  console.log(111);//111不会输出，因为报错了\n}catch(e){\n  console.log(e);\n}\n```\n## try只要里面的出现了报错，后面的代码就不会去执行\n\n","categories":["JAVASCRIPT"]},{"title":"移动端","url":"/2018/03/19/HTML/移动端/","content":"\n#移动端宽度写死的话，有什么利弊\n好处：简单，可以使用px了\n弊端：无法做响应式的处理了，应为宽度是定死了\n\n\n#尺寸和分辨率不一样","categories":["HTML"]},{"title":"documentElement","url":"/2018/03/19/HTML/documentElement/","content":"\n# 是什么？？？\n```\n<html></html>\n```\n# document.body\n```\n<body></body>\n```\ndocument.body是DOM中Document对象里的body节点\ndocument.documentElement是文档对象根节点(html)的引用。","categories":["HTML"]},{"title":"marquee","url":"/2018/03/19/HTML/marquee/","content":"\n# marquee\n- behavior\n    - alternate:两端之间来回滚动\n    - scroll:由一端滚动到另一边，会重复\n    - slide:由一端滚动到另一边，不会会重复\n- direction\n    - left:\n    - right:\n    - up:\n    - down:\n- loop:\n    - -1:默认值，表示无限滚动\n- scrollamount:活动字幕的滚动速度\n- scrolldelay:活动字幕滚动两次之间的延迟时间,就是两次运动的间隔时间,单位为毫秒\n\n```\n    <marquee behavior=\"alternate\" \n    onmouseover=\"this.stop()\"\n    onmouseout='this.start()'\n    direction=\"left\" scrollamount=1 scrolldelay=3000>test</marquee>\n\n```\n\n\n```\n\n   onmouseover=\"this.stop()\"\n    onmouseout='this.start()'\n\n```\n这里的start,stop函数不用自己定义，浏览器提供，固定格式就这么写\n\n\n# 缺点\n- 无法自定义滚动形式，比如，marquee只能在内容都滚动完成后再进行下一次滚动，无法实现无缝滚动\n\n\n","categories":["HTML"]},{"title":"笔记","url":"/2018/03/19/ES6/笔记/","content":"\n# ES6 声明变量的六种方法\n- var\n- function\n- let\n- const\n- import\n- class\n\n\n\n# 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值\n\n# 解构赋值\n- 数组解构赋值\n- 对象解构赋值\n- 字符串解构赋值\n- 函数参数的解构赋值\n\n```\n//数组解构赋值\nlet [a, b, c] = [1, 2, 3];\n```\n\n```\n//对象解构赋值\nlet data={\n    name:'xxx',\n    title:'asdf',\n    sex:'zdsf'\n}\nlet {name,title}=data;\n/////////////\nlet data={\n    name:'xxx',\n    title:'asdf',\n    sex:'zdsf'\n  }\n  let {name:Name,title:Title}=data;\n  console.log(Name,Title);\n```\n## 这两种写法是等价的，换句话说，本质上是赋值给val，不是给可以的\n\n\n# 解构赋值的作用\n- 交换变量的值\n- 从函数返回多个值，可以方便的赋值\n- 函数参数的定义，可以将一组参数与变量名对应起来\n- **提取JSON数据**\n- 函数参数的默认值\n- 遍历Map结构\n- 输入模块的指定方法\n\n\n```\n//遍历Map结构\nconst map = new Map();\nmap.set('first', 'hello');\nmap.set('second', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n```\n\n# 什么时候解构会不成功？\n- 总的说就是两边的解构不一样\n\n\n# 默认值生效的条件是，对象的属性值严格等于undefined。\n\n    \n\n# Number.parseInt(), Number.parseFloat()\n\nES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。\n\n\n# 指数运算符\n```\n2 ** 2 // 4\n2 ** 3 // 8\n\n\nlet a = 1.5;\na **= 2;\n// 等同于 a = a * a;\n```\n\n## 这是参数默认值情况吗\n```\nfunction foo({y = 5}) {\n  console.log(y);\n}\n```\n**不是，这是解构赋值**\n# 如果一个函数的参数是一个对象，或者是一个数组，那么这一定是解构赋值\n\n```\nfunction foo({y = 5}={}) {\n  console.log(y);\n}\n```\n这种情况就是解构赋值和参数的默认值结合的情况了\n\n\n#函数的 length 属性:该函数预期传入的参数个数\n将返回没有指定默认值的参数个数\n```\n(function (a) {}).length // 1\n(function (a = 5) {}).length // 0\n(function (a, b, c = 5) {}).length // 2\n(function(...args) {}).length // 0\n```\n\n# 参数作用域\n```\nvar x = 1;\n\nfunction f(x, y = x) {\n  console.log(y);\n}\n\n```\nf(1)会有什么结果？？？\n1\n\n一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。\n\n\n\n# 箭头函数牛逼的地方：函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n\n```\nfunction foo() {\n  setTimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\nvar id = 21;\n\nfoo.call({ id: 42 });\n```\n\n\n# 扩展运算符\n\n扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列\n\n\n\n\n# 创建 pure objects\n\n你可以创建一个 100% pure object，它不从 Object中继承任何属性或则方法（比如 constructor, toString()等）\n\n```\nconst pureObject = Object.create(null);\nconsole.log(pureObject); //=> {}\nconsole.log(pureObject.constructor); //=> undefined\nconsole.log(pureObject.toString); //=> undefined\nconsole.log(pureObject.hasOwnProperty); //=> undefined\n```\n\n# await 多个 async 函数\n\n在使用 async/await 的时候，可以使用 Promise.all 来 await 多个 async 函数\n\n```\nawait Promise.all([anAsyncCall(), thisIsAlsoAsync(), oneMore()])\n```\n\n\n\nPromise它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载\n\n\n\nsetTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行\n\n\nsetTimeout()只是将事件插入了\"任务队列\"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数\n\n# V8 javascript 引擎 到底是做什么的，为什么浏览器有他，nodejs也需要他?\n很简单，解析js的，我们写的js，机器是不认识的，需要转换成机器识别的机器码才可以执行\n因为浏览器里面有js，node就是js写的，所以自然都需要这个v8引擎了\n\n\n# setImmediate与setTimeout(fn,0)哪个回调函数先执行呢？\n答案是不确定\n\n令人困惑的是，Node.js文档中称，setImmediate指定的回调函数，总是排在setTimeout前面。实际上，这种情况只发生在递归调用的时候。\n\n\n\n\n基本上，如果你希望异步任务尽可能快地执行，那就使用process.nextTick。\n\n\n# 微任务\nPromise对象的回调函数，会进入异步任务里面的\"微任务\"（microtask）队列。\n\n微任务队列追加在process.nextTick队列的后面，也属于本轮循环\n\n\n\n# 本轮循环的执行顺序\n1-同步任务\n2-process.nextTick()\n3-微任务\n\n\n\n有些人以为，除了主线程，还存在一个单独的事件循环线程。不是这样的，只有一个主线程，事件循环是在主线程上完成的","categories":["ES6"]},{"title":"异步执行","url":"/2018/03/19/ES6/异步执行/","content":"\n\n# 如何执行异步？\n- 回调函数\n- 事件监听\n- 发布/订阅\n\n# 回调函数\n最常见的执行异步操作的方式\n优点:最常见，最好理解\n缺点:回调地狱,高度耦合,无法维护\n\n\n# 事件监听\n最常见的执行异步操作的方式\n优点:好理解，去耦合\n缺点:运行流程不清晰(比如，绑定了两个函数，哪个先执行都不知道，)\n\n\n# 发布/订阅(观察者模式)\n这个和事件监听很相似，但是比他高级\n所有的程序运行权利都交由'信号中心'决定，可以从整体上把握整个程序的运行流程\n优点:去耦合，运行流程清晰\n缺点:不好理解\n\n\n","categories":["ES6"]},{"title":"promise","url":"/2018/03/19/ES6/promise/","content":"\n\n# 如何执行异步代码？\n\n\n\n浏览器端的异步操作的常见情况\n- 定时器\n- ajax加载数据\n\n\n\n\n# Promise对象是一个构造函数，用来生成Promise实例\n\n**所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果**\n\n**从语法上说，Promise 是一个对象，从它可以获取异步操作的消息**\n\n\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\n\n# Promise.prototype.then()\n**它的作用是为 Promise 实例添加状态改变时的回调函数**\n\nthen方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法\n\n```\np.then().then()\n//虽然then返回的是一个promise，但是头一个then返回的promise没有设定resolve，reject，所以，第一个then执行完成后，第二个then会立即执行\n//如何实现第一个then里面函数执行完成后过一段时间再执行第二个then呢？再第一个then里面继续返回一个自己设定的promise\n```\n\n**第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数**\n\n\n# 缺点\n- 无法取消Promise\n- 如果不设置回调函数，Promise内部抛出的错误\n- 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）\n\n\n\n# then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行\n\n\n# Promise.prototype.catch()\nPromise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。\n**他捕获的是promise里面的错误，还是then里面的错误**:都捕获，但是需要注意的是，如果一个地方报错停住了，then里面的resolve代码就不会执行了，\n\n\n```\ngetJSON('/post/1.json').then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // some code\n}).catch(function(error) {\n  // 处理前面三个Promise产生的错误\n});\n\n```\n\n上面代码中，一共有三个 Promise 对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。\n\n一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。\n\n跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。\n\nPromise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。\n\n\n\n一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。\n\n\n# Promise.all([p1,p2,p3]):将多个promise包装成一个promise,所有子promise resolve/reject，才会then\n# Promise.race([p1,p2,p3]):将多个promise包装成一个promise,只要有一个primise resolve/reject,就会then\n# Promise.resolve():将普通对象转化为promise对象\n ```\n Promise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n ```\n# Promise.reject():返回一个新的 Promise 实例，该实例的状态为rejected。","categories":["ES6"]},{"title":"let中es6中那些升级后的不.","url":"/2018/03/19/ES6/let中es6中那些升级后的不/","content":"\n# 在es6中\n- 不允许变量提升\n\n在let中\n- 不允许重复声明变量","categories":["ES6"]},{"title":"genertor","url":"/2018/03/19/ES6/genertor/","content":"\n# 和promise有关系吗？\n没关系\n\n\nGenerator 函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。\n\n\nGenerator 函数将异步操作表示得很简洁，但是流程管理却不方便\n\n\nyield语句运行的时候是同步运行，而不是异步运行（否则就失去了取代回调函数的设计目的了）。实际操作中，一般让yield语句返回Promises对象。\n\n\n\n\nasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回(**会返回什么东西吗，还是干等着**)，等到异步操作完成(**如何判断异步操作完成**)，再接着执行函数体内后面的语句。\n\n# await:如何判断异步操作完成?\n自己理解:await后面跟着的是一个promise对象，这个对象的resolve方法执行完成，就表示异步操作执行完成了，话句话说，await后面只有一个回调函数，不能有多个，这样起始很好，避免了回调的嵌套\n\n# await返回的结果，到底是什么\nresolve方法，传入的参数的第一个\n\n# await 后面到底跟的是个什么东西？\nawait命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n\n\n# async await 返回的都是promise\n\n\n\n## async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n\n\n## 正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。\n\n## 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。","categories":["ES6"]},{"title":"for 中的let","url":"/2018/03/19/ES6/for 中的let/","content":"```\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 10\n```\n\n```\nvar a = [];\nfor (let i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 6\n```\n## 为什么\n\n\n\nfor循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域","categories":["ES6"]},{"title":"async","url":"/2018/03/19/ES6/async/","content":"\n# async，异步编程的终极解决方案\n本质上就是gengerator的语法糖，可有可无\n但是，只有gengerator的话，非常难以使用，需要配合很多第三方的库才可以让generator自动执行，很麻烦\n\n使用了async的话，自带自动执行，无需其他插件，易用性上远远胜过gengerator原生功能\n\n# 四大特点\n- 内置执行器\n- 更好的语义\n- 更广的适用性\n- 返回值是 Promise\n\n**最主要的其实就是自动执行的功能**\n\n```\n\nfunction fn1() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(444);\n      resolve(444);\n    }, 3000);\n  });\n};\n\n\nfunction fn2() {\n  return 555;\n};\n\n\nasync function test() {\n  console.log(333);\n  let val1=await fn1();\n  console.log(val1);\n  let val2=await fn2();\n  console.log(val2);\n  console.log(6666);\n}\n\ntest();\n\n//333 3s 444 444  555 666\n\n```\n\n1、执行流程\n```\ntest();//开始执行\n```\n2\n```\n console.log(333);\n```\n\n3\n```\n let val1=await fn1();//fn1，返回的是一个promise，只有当这个promise状态发生变化的时候，也就是resolve的时候，resove传入的参数，就是val1的数值，这样，所有的异步操作就可以放到fn1里面就可以，\n```\n省略.......\n\n4\n```\nlet val2=await fn2();\n//fn2函数返回的就是一个普通的数值，那么val2就会得到这个函数的返回值，其实这样的话，就相当于同步操作了，没什么意义了\n```\n省略.......\n\n\n\n# await 得到的是什么？\n\n正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。\n\n\n# 使用注意点\nawait 后面一般是promise，如果reject了，怎么办？？？\n\n最好把await命令放在try...catch代码块中\n\n","categories":["ES6"]},{"title":"es6&&es2015","url":"/2018/03/19/ES6/es6&&es2015/","content":"\n# es6\n\nES6 既是一个历史名词，也是一个泛指，含义是5.1版以后的 JavaScript 的下一代标准，涵盖了ES2015、ES2016、ES2017等等\n\n# es2015,es2016,es2017\n是正式名称，特指该年发布的正式版本的语言标准\n\n\n","categories":["ES6"]},{"title":"半圆","url":"/2018/03/19/CSS/半圆/","content":"\n```\ndiv {\n  height: 50px;\n  /*是width的一半*/\n  width: 100px;\n  background: #9da;\n  border-radius: 50px 50px 0 0;\n  /*半径至少设置为height的值*/\n}\n\n```","categories":["CSS"]},{"title":"三角形的制作","url":"/2018/03/19/CSS/三角形的制作/","content":"\n","categories":["CSS"]},{"title":"移动端的css","url":"/2018/03/19/CSS/移动端的css/","content":"\n# viewport\n- visual viewport:视口viewport 或者度量viewport\n  就是实际看到的像素大小，这个数值从chrome的调试工具来看到\n- layout viewport:布局viewport\n 布局视口:默认980px\n- 度量viewport\n\n\ninitial-scale=1 表示将layout viewport（布局视口）的宽度设置为 ideal viewport（理想视口）的宽度\n\n```\n<meta name=\"viewport\" content=\"width=320\">\n\n```\n这样做的话，就是修改了layout viewport了\n\ndocument.body.clientWidth:得到设置的wiewport的width数值\nwindow.innerWidth:得到的是页面的width数值\n\n#参考链接\n- http://blog.csdn.net/maxbyzhou/article/details/53243982","categories":["CSS"]},{"title":"文字溢出显示省略号","url":"/2018/03/19/CSS/文字溢出显示省略号/","content":"\n要实现溢出时产生省略号的效果，还须定义强制文本在一行内显示（white-space:nowrap）及溢出内容为隐藏（overflow:hidden），只有这样才能实现溢出文本显示省略号的效果，代码如下：\n\n```\ntext-overflow:ellipsis; \noverflow:hidden; \nwhite-space:nowrap; \n```","categories":["CSS"]},{"title":"Symbol","url":"/2018/03/19/ES6/Symbol/","content":"\n# Symbol:独一无二的值\n\n","categories":["ES6"]},{"title":"css基础","url":"/2018/03/19/CSS/css基础/","content":"\n# margin 垂直方向会叠加，水平方向不会\n```\n<template>\n<div class=\"cart\">\n  <div class=\"box1\"></div>\n  <div class=\"box2\"></div>\n</div>\n</template>\n\n<style lang=\"scss\">\n  .cart{\n    div{\n      width:10px;\n      height: 10px;\n      background-color: #aaa;\n      margin: 10px;\n      float:left;\n    }\n  }\n</style>\n\n```\n\n```\n<template>\n<div class=\"cart\">\n  <div class=\"box1\"></div>\n  <div class=\"box2\"></div>\n</div>\n</template>\n\n<style lang=\"scss\">\n  .cart{\n    div{\n      width:10px;\n      height: 10px;\n      background-color: #aaa;\n      margin: 10px;\n    }\n  }\n</style>\n```\n\n# float\n本意就是图片和文本排版的一种方式，但是也非常适合排版\n\n# 围住浮动的三种方法\n- 父元素添加 overflow:hidden;\n- 同时浮动父元素\n- 添加非浮动的清除元素\n- clearfix\n```\n.clearfix:after {\n    content:\".\";\n    display:block;\n    height:0;\n    visibility:hidden;\n    clear:both;\n}\n```\n\n\n# 没有父元素时如何清除\n最简单的办法就是给一个浮动元素应用clear:both\n\n# 定位\n- static:默认的static 文档流\n\n# relative\n相对定位的关键是什么呢？就是要考虑到元素原来的空间\nrelative 脱离文档流了吗？\n\n# 什么是文档流\n\n# absolute\n\n绝对定位元素默认的定位上下文是body 元素\n\n由于绝对定位元素的定位上下文是body，所以在页面滚动的时候，为了维护与body\n元素的相对位置关系，它也会相应地移动。\n\n# 定位上下文\n把元素的position 属性设定为relative、absolute 或fixed 后，继而可以使用top、\nright、bottom 和left 属性，相对于另一个元素移动该元素的位置。这里的“另一\n个元素”，就是该元素的定位上下文。\n\n\n# 显示属性\n- 块级元素，比如段落、标题、列表等，在浏览器中上下堆叠显示。\n- 行内元素，比如a、span 和img，在浏览器中左右并排显示，只有前一行没有空间\n时才会显示到下一行。\n\n# 通用的字体类\n- serif，也就是衬线字体，在每个字符笔画的末端会有一些装饰线；\n- sans-serif，也就是无衬线字体，字符笔画的末端没有装饰线；\n- monospace，也就是等宽字体，顾名思义，就是每个字符的宽度相等（也称代码体）；\n- cursive，也就是草书体或手写体\n- fantasy，不能归入其他类别的字体（一般都是奇形怪状的字体）。\n\n# 头三个极有可能在Mac 和PC 中都安装了。\n\n# 字符间距 ：letter-spacing\n文字与文字之间的间距，中英都可以\n#单词间距:word-spacing\n## CSS 把任何两边有空白的字符和字符串都视作“单词\"\n中英都可以\n\n# 垂直对齐 :vertical-align\nvertical-align 以基线为参照上下移动文本，但这个属性只影响**行内元素**\n\n如果你\n想在垂直方向上对齐块级元素，必须把其display 属性设定为inline。vertical-align\n属性最常用于公式或化学分子式中的上标和下标，比如x4-y-5 或N3O，或者用于文本\n中脚注的角标，比如把星号变成上角标。\n\n# 布局\n\n# 三栏-固定宽度布局\n思路：计算三栏的总宽度为父wrapper的总宽度即可，三栏都是float:left，注意三栏的每个栏目的padding不要影响总宽度，最好是使用每个栏目的子元素的padding\n\n# 三栏-中栏流动布局\n就是左右栏固定宽度，中间栏目宽度不固定\n## 用负外边距实现\n#用CSS3 单元格实现 display:table-cell 这种方式最为简单，ie67不支持，ie8支持\n\n# 人造栏\n\n\n# 响应式设计包含三个重要的方面。\n- 媒体查询：是一种CSS 语法，可以根据浏览器的特性，一般是屏幕或浏览器容器宽度提供\nCSS 规则；\n- 流式布局：是使用em 或百分比等相对单位设定页面总体宽度，让布局能够随屏幕大小而\n缩放；\n- 弹性图片：是使用相对单位确保图片再大也不会超过其容器。\n\n\n\n浏览器忽略HTML 代码中的空格符、回车符和制表符，但保留文本之间的空白——\n多个空白符只保留一个。举个例子，下面这几行全都是等价的HTML 代码，它们的\n结果都是显示：An HTML paragraph element。\n```\n<p>An HTML paragraph element</p>\n<p>A HTML paragraph element</p>\n<p>\nAn HTML paragraph element\n</p>\n\n```\n\n\n```\n<!--[if lte IE 8]> <!-- IE 条件注释 -->\n<link src=\"ie_only.css\" rel=\"stylesheet\" />\n<![endif]-->\n```\n这种特殊格式的HTML 注释会被非IE 浏览器忽略，只有IE 浏览器才会执行其中的\n代码。就这个例子而言，我们是在为IE8 及更低版本的IE 加载额外的样式。加载条\n件可以使用lte（less than or equal to，小于等于）、lt（less than，小于）、gte（greater\nthan or equal to，大于等于）、gt（greater than，大于），甚至只写一个浏览器版本号\n如IE 6。以此为不同版本的IE 提供后备代码。\n\n\n\n# 腻子脚本\n- HTML5shiv.js（http://code.google.com/p/html5shiv）：让IE8 及更低版本的IE 识别\nsection、 article、nav 等HTML5 元素。\n- selectivizr（http://www.selectivizr.com）：让IE（6/7/8）支持::first-child 等高级\nCSS 选择符。\n- IE9.js（http://code.google.com/p/ie7-js）：修复从IE6 到IE9 的很多bug 和缺损\n功能。\n- CSS3Pie（http://css3pie.com）：让IE6 到IE9 支持圆角、背景渐变、边框图片、盒\n阴影、RGBa 颜色等可视化的CSS3 功能。\n- Respond.js（https://github.com/scottjehl/respond）让旧版本浏览器支持媒体查询。\n- -prefix-free（http://lea.verou.me/projects）为需要厂商前缀的CSS3 声明添加前缀（参\n见第4 章）。\n- borderBoxModel.js（https://github.com/albertogasparin/borderBoxModel）：让IE6 和\nIE7 支持CSS3 的box-sizing 属性。\n\n","categories":["CSS"]},{"title":"css写一个正方体","url":"/2018/03/19/CSS/css写一个正方体/","content":"\n# 一知半解\n```\ndiv.container {\n  transform-style: preserve-3d;\n  perspective: 1000;\n  border: 1px solid #eee;\n  padding: 300px 0;\n  text-align: center;\n  &:hover {\n    .box {\n      transform-origin: 150px,150px;\n      transform: rotate3d(0.3,0.4,0.3,180deg);\n    }\n  }\n  .box {\n    transition: all 1s;\n    display: inline-block;\n    position: relative;\n    transform-style: preserve-3d;\n    perspective: 500;\n    width: 300px;\n    height: 300px;\n    transition: all 5s;\n    .main {\n      width: 300px;\n      height: 300px;\n      background-color: #aaa;\n      position: absolute;\n      font-size: 100px;\n      color: #fff;\n      text-align: center;\n      line-height: 300px;\n      &.qian {\n        background-color: red; \n        transform: translateZ(150px);\n      }\n      &.hou {\n        background-color: yellow;\n      }\n      &.zuo {\n        background-color: rebeccapurple;\n        transform: translateX(-150px) rotateY(-90deg);\n      }\n      &.you {\n        background-color: yellowgreen;\n        transform: translateX(150px) rotateY(-90deg);\n      }\n      &.shang {\n        background-color: burlywood;\n        transform: translateY(-150px) rotateX(90deg);\n      }\n      &.xia {\n        background-color: brown;\n        transform: translateY(150px) rotateX(90deg);\n      }\n    }\n  }\n}\n\n```","categories":["CSS"]},{"title":"flex","url":"/2018/03/19/CSS/flex/","content":"\nFlex:IE9+支持\n\n[案例地址](http://static.vgee.cn/static/index.html)\n\n\n> 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n\n\n## 容器的属性\n- flex-direction:主轴的方向(**row** | row-reverse | column | column-reverse)\n- flex-wrap:如果一条轴线排不下，如何换行(**nowrap** | wrap | wrap-reverse)\n- flex-flow:flex-direction属性和flex-wrap属性的简写形式，默认值为 **row nowrap**\n- justify-content:水平对齐方式( **flex-start** | flex-end | center | space-between | space-around)\n- align-items:垂直对齐方式( flex-start | flex-end | center | baseline | **stretch**)\n- align-content:多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。(flex-start | flex-end | center | space-between | space-around | **stretch** )\n\n\n## 项目的属性\n- order:排列顺序。数值越小，排列越靠前，默认为0\n- flex-grow:项目的放大比例，默认为 **0** ，即如果存在剩余空间，也不放大\n- flex-shrink:项目的缩小比例，默认为 **1**，即如果空间不足，该项目将缩小。\n- flex-basis:在分配多余空间之前，项目占据的主轴空间,浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 **auto**，即项目的本来大小\n- flex:flex-grow, flex-shrink 和 flex-basis的简写，默认值为 **0 1 auto** 。后两个属性可选,(flex:auto===1 1 auto,flex:none===0 0 auto)\n- align-self:允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为 **auto**，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch(auto | flex-start | flex-end | center | baseline | stretch)\n\n注意点\n- 项目的width,如果容器的空间够用，会按照默认的设置大小展示，如果不够，width会自动调整，所以，width可能会改变\n- 项目的float、clear和vertical-align会失效\n- 如果项目未设置高度或设为auto，将占满整个容器的高度。设置了的话，就按照设置的高度展示，一般不能设置height\n- align-content定义的是多根轴线的对齐方式，不是项目，是轴线，比如定义为stretch，那么表示的意思就是多个轴线将拉伸，占满整个容器\n","categories":["CSS"]},{"title":"textarea限制横向拖动","url":"/2018/03/19/CSS/textarea限制横向拖动/","content":"\n```\ntextarea {\n  -webkit-resize: horizontal;\n  -moz-resize: horizontal;\n  -o-resize: horizontal;\n  -ms-resize: horizontal;\n  resize: horizontal;\n}\n```","categories":["CSS"]},{"title":"transform","url":"/2018/03/19/CSS/transform/","content":"\n语法\n```\ntransform:变换1 变换2;\n//中间空格隔开\n```\n\n# 常用变换\n- rotate\n- translate\n- scale\n\n# 需要注意的属性\n- 原点\n- \n\n","categories":["CSS"]},{"title":"简单markdown","url":"/2018/03/19/DEMO/简单markdown/","content":"\n\n\n","categories":["DEMO"]},{"title":"表格排序","url":"/2018/03/19/DEMO/表格排序/","content":"\n\n\n","categories":["DEMO"]},{"title":"animate && transition","url":"/2018/03/19/CSS/animate && transition/","content":"\n# 两者区别\n\ntransition的优点在于简单易用，但是它有几个很大的局限。\n（1）transition需要事件触发，所以没法在网页加载时自动发生。\n（2）transition是一次性的，不能重复发生，除非一再触发。\n（3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。\n（4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。\n\n\n# transition 用法\n\ntransition: duration delay property timing-function","categories":["CSS"]},{"title":"3D变换","url":"/2018/03/19/CSS/3D变换/","content":"\n# 设置3D场景\nperspective:800\nperspective-origin:50% 50%;\ntrasnform-style:preserve-3d;\n\n![](/images/css/3D/1.jpg)\n\n\n# 背面看不到\nbackface-visibility:hidden;\n这个地方很有意思，实际测试中，发现到rotateX(90deg)的时候，我还可以看到内容，这可能是浏览器实现的问题，当设置背面看不到的时候，就正常了","categories":["CSS"]},{"title":"自动循环播放的广告条","url":"/2018/03/19/DEMO/自动循环播放的广告条/","content":"\n\n## 实现一个自动循环播放的广告条\n\n- 广告的条数不固定，为0则隐藏广告位，有几条就展示几条。\n- 图片尺寸固定，不需要考虑图片剪裁\n- 广告的图片从远端拉取，每拉到一条就展示一条，动态添加。\n- 自动循环播放，并且支持手动滑动。\n- 带有导航点，点击可以跳转对应广告\n- 点击广告位可以有不同的效果：本地跳转，跳转浏览器，弹窗\n\n","categories":["DEMO"]},{"title":"瀑布流","url":"/2018/03/19/DEMO/瀑布流/","content":"\n\n\n\n","categories":["DEMO"]},{"title":"时间插件","url":"/2018/03/19/DEMO/时间插件/","content":"\n\n\n","categories":["DEMO"]},{"title":"无限滚动效果","url":"/2018/03/19/DEMO/无限滚动效果/","content":"\n\n\n","categories":["DEMO"]},{"title":"loading效果","url":"/2018/03/19/DEMO/loading效果/","content":"\n\n\n","categories":["DEMO"]},{"title":"vuejs-多站点管理平台","url":"/2018/03/19/DEMO/vuejs-多站点管理平台/","content":"\n# 要求，可以非常方便的管理系统后台\n\n\n\n","categories":["DEMO"]},{"title":"锋利的JQUERY","url":"/2018/03/19/BOOK/锋利的JQUERY/","content":"\n\n# 隐式迭代\n比如 获得 隐藏 .myclass 的元素，默认是隐藏所有的，jquery的方法都是被设计成自动操作对象集合\n\n# DOM对象和Jquery对象相互转换\n##  jquery->dom：\n```\n$('#ad')[0]\n$('#ad').get(0)\n```\n因为jquery对象是一个类数组的对象\n\n## dom->jquery\n```\n$(dom)\n```\ndom对象是不可以使用jquery提供的方法\njquery对象也是不可以使用dom对象的方法的\n\n#冲突\njQuery.noConflict()\n```\nvar my=jQuery.noConflict();\nconsole.log($,jQuery,my);//undefined,fn(){},fn(){}\n\nvar my=jQuery.noConflict(true);\nconsole.log($,jQuery,my);//undefined,undefined,fn(){}\n```\n\n#选择器\n```\n$('a+b')://a同级的下一个b\n$('a~b')://a同级的所有b\n\n$('a+b') === $('a').next('b')\n$('a~b') === $('a').nextAll('b')\n\n\n//过滤选择器\n$('a:first')://所有的a中的第一个\n$('a:last'):\n$('a:eq(1)')://所有的a中索引是第一个,从0开始   $('a:first')==$('a:eq(0)')\n$('a:gt(1)'):\n$(':header')://获取h1,h2,...所有的h*元素\n$(':animated')://正在执行动画的元素\n$(':focus')://获得焦点的元素\n\n\n//内容过滤选择器\n$(':contain(text)')://匹配包含给定文本的元素,\n$(':empty')://空元素\n$(':has(selector)')://包含selector的父元素\n$(':parent')://匹配含有子元素或者文本的元素,如果子元素或者文本为空，则匹配不到\n\n\n\n//特殊用法\nvar res=$('.res');\nconsole.log($('h2',res));//表示在res中查找h2\n```\n\n# querySelector和querySelectorAll IE8+浏览器支持。\n\n#DOM操作\n- 查找\n    - children()\n    - next()\n    - prev()\n    - siblings()\n    - closest():查找当前元素->查找父级元素->父父....->null(注意:不会查找同级元素)\n    - parent()\n    - parents()\n- 创建\n    - $('<h1>new element</h1>')\n- 插入\n    - append()/appendTo()\n    - prepend()/prependTo()\n    - after()/insertAfter()\n    - before()/insertBefore()\n- 删除\n    - remove():不保留事件\n    - detach():保留事件\n    - empty()\n- 替换\n    - replaceWidth()/replaceAll()\n- 复制\n    - clone()\n- 包裹\n    - wrap()\n    - wrapAll()\n    - wrapInner()\n- 属性操作\n    - attr()\n    - removeAttr()\n    - prop()\n    - removeProp()\n- CSS操作\n    - addClass()\n    - removeClass()\n    - toggleClass()\n- HTML/text操作\n    - HTML()\n    - text()\n    - val()\n\n\n# 位置\n- offset():获得元素相对于document.documentElement的距离，这个方法原生的没有，需要一层一层的offsetLeft/offsetTop才能实现\n- position():原生的offsetLeft/offsetTop\n- scrollTop()/scrollLeft(可传参数):原生scrollTop/scrollLeft的封装\n\n\n\n# 事件\n ## $(function(){}) === $().ready() === $(document).ready()  >  window.onload == $(window).load()\n    $(document).ready():可以使用多次，会按照注册顺序依次执行\n ## 合成事件\n    原始事件中没有，jq自己合成的\n    - hover()\n    - toggle():1.9+版本删除,只用于显示隐藏\n\n- bind(type,[data],fn)\n- one(type,[data],fn):和bind一样，就是只会执行一次\n- unbind(type,[fn])\n- trigger(type,[data])\n\n\n## 注意事项\n - bind('type1 type2'):多个事件，空格隔开\n - 命名空间，方便管理\n ```\n function fn1(){console.log(1)}\n    function fn2(){console.log(2)}\n    function fn3(){console.log(3)}\n    $('.btn').bind('click.type1',fn1);\n    $('.btn').bind('click.type1',fn2);//本质是自定义事件\n    $('.btn').bind('click.type2',fn3);\n    $('.btn').unbind('.type1')\n ```\n\n ## event\n    - ev.stopPropagation();对原始的event.stopPropagation()的方法的封装,兼容各种浏览器\n    - ev.preventDefault();对原始的event.preventDefault()的方法的封装,兼容各种浏览器\n    - event.type\n    - event.target\n    - event.relatedTarget\n    - event.pageX/pageY:对原始的event.pageX的封装\n    - event.which：滚轮\n    - event.metaKey\n \n\n# 动画\n ## speed \n    - slow :0.6s\n    - normal:0.4s\n    - fast:0.2s\n - show([speed])/hide([speed]):opcity/width/height\n - fadeIn([speed],[easing],[callback])/fadeOut():opcity\n - slideIn()/slideOut():height\n - animate(params,[speed],[callback])\n    - 累加:$('.box').animate({left:'+=100px'})\n    - 多重动画，顺序动画\n        - $('.box').animate({left:'100px',top:'100px'}):多重，同时进行\n        - $('.box').animate({top:'100px'}).animate({top:'100px'}):多重，顺序进行\n- stop([clearQueen],[gotoend])\n  默认:停止当前动画，开始下一个动画\n  stop(true,false):停止在动画代码执行的动画状态，不会开始下一个动画\n  stop(false,true):停止当前动画到结束状态，后续动画不会执行\n  stop(false,false):停止在代码执行的动画状态，开始下一个动画\n  stop(true,true):停止到第一个动画到结束状态，后续动画不会执行\n- 是否处于动画状态:$(ele).is(':animated')\n- delay():延迟动画\n\n## 专门的交互动画\n- toggle()\n- slideToggle()\n- fadeTo()\n- fadeToggle()\n\n\n# end()\n\n\n# ajax\n- $.load(url,[data],[callback]):远程载入代码并且插入dom中\n- $.load('url #box',[data],[callback]):远程载入代码并且插入dom中,并且筛选\n- $.getScript(),$.getJson()\n\n## 数据格式\n- xml\n- HTML\non\najax可以设置默认的返回数据格式，原理设置发送的http请求头`Accept:application/xml, text/xml`,\n问题:如果请求的是一个返回json数据的接口，而我设置的格式是html，会怎么样？？？？\n我将得不到数据\n问题，设置正确的话，我将可以直接得到对应类型的数据，比如我设置为json，那么返回的数据就是json，这个格式是jquery重又处理的，还是怎么滴？\n\n\n##  $.getScript()\n    ```\n    $.getScript('https://cdn.bootcss.com/lodash.js/4.17.4/lodash.js')\n    ```\n    执行后，可以直接使用lodash，不用在append到head中去了\n##  $.getJSON():\n    返回结果直接是json，并且支持jsonp\n\n# $.ajax()\n- url:\n- type\n- timeout\n- data\n- dataType\n- beforeSend\n- complete\n- success\n- error\n- global\n\n# ajax全局事件\n- $(document).ajaxStart():\n- $(document).ajaxStop():\n- $(document).ajaxComplete():\n- $(document).ajaxError():\n- $(document).ajaxSuccess():\n- $(document).ajaxSend():\n- $(document).ajaxSend():\n**jquery1.9+版本以后，ajax全局事件需绑定到document对象上才能触发。**\n\n$.ajax({\n    global:false\n})\n这样设置后，改请求就不会触发全局事件了\n\n\n\n# 序列化\n- serialize();\n- serializeArray();\n- $.param():核心方法,对象序列化\n\n\n# encodeURI && decodeURI\n\n\n# 插件\n## validate插件\n```\n\n\n$('#login_box').submit(function(ev){\n    ev.preventDefault();\n    \n    $(this).validate({\n        rules:{\n            username:{\n                required:true\n            },\n            pwd:{\n                required:true,\n                \n            },\n            verify:{\n                required:true,\n                remote:{\n                    url:'http://www.test.com/validate.php',\n                    type:'post',\n                    data:{\n                        verify:$('[name=\"verify\"]').val(),\n                    }\n                }\n            }\n        },\n        messages: {  \n            pwd: {  \n                required: \"密码不能为空\", \n            },\n            verify:{\n                remote:'验证码错误' \n            }\n        }  \n    });\n})\n\n```\n\n```\n//http://www.test.com/validate.php\n\n\n<?php\nheader('access-Control-Allow-Origin:*');\n\n$res=false;\n\n\n$res=json_encode($res);\n\nif(  isset($_GET['callback'])  ){\n    // echo 111;\n    echo $_GET['callback'].\"($res)\";\n}else{\n    echo $res;\n}\n\n\n```\n验证返回的结果只是`json_encode(true/false)`即可\n\n## form\nhttp://malsup.com/jquery/form/\n可以非常容易地、无侵入地升级HTML表单以支持Ajax\n\n## modal\nhttps://github.com/ericmmartin/simplemodal\n\n这个插件在高版本的jquery中有问题，使用1.*的版本\n\n## cookie\n\n\n\n# jquery ui","categories":["BOOK"]},{"title":"无缝滚动效果","url":"/2018/03/19/DEMO/无缝滚动效果/","content":"\n\n# marquee效果\n\n```\n\n\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n\n</head>\n\n<body>\n    <h1>test</h1>\n    <div class=\"box\">\n        <ul>\n            <li>\n                <a href=\"\">1无缝滚动</a>\n            </li>\n            <li>\n                <a href=\"\">2无缝滚动</a>\n            </li>\n            <li>\n                <a href=\"\">3无缝滚动</a>\n            </li>\n            <li>\n                <a href=\"\">4无缝滚动</a>\n            </li>\n\n            <li>\n                <a href=\"\">5无缝滚动</a>\n            </li>\n\n            <li>\n                <a href=\"\">6无缝滚动</a>\n            </li>\n\n            <li>\n                <a href=\"\">7无缝滚动</a>\n            </li>\n        </ul>\n        <ul class=\"back\"></ul>\n    </div>\n\n\n\n</body>\n\n</html>\n\n<style>\n    * {\n        margin: 0;\n        padding: 0;\n        list-style: none;\n    }\n\n    .box {\n        width: 500px;\n        margin: 100px auto;\n        height: 100px;\n        border: 1px solid #eee;\n        background-color: #bbb;\n        overflow: auto;\n    }\n\n    ul {\n        border: 1px solid #aaa;\n    }\n</style>\n<script src=\"jquery.js\"></script>\n<script>\n    var box = document.querySelector('.box');\n    var ul = document.querySelector('ul');\n    var h1 = document.querySelector('h1');\n    var lis = document.querySelectorAll('li');\n    var timer = null;\n    var back=document.querySelector('.back');\n    back.innerHTML=ul.innerHTML;\n    function start() {\n        timer = setInterval(function () {\n            if (ul.clientHeight <= box.scrollTop) {\n                console.log(1111);\n                box.scrollTop=0;\n            } else {\n                box.scrollTop++;\n            }\n        }, 50);\n\n    }\n\n    start();\n\n    function end() {}\n    box.addEventListener('mouseover', function () {\n        clearInterval(timer);\n    });\n    box.addEventListener('mouseout', function () {\n        start();\n    });\n</script>\n\n\n```\n\n","categories":["DEMO"]},{"title":"JavaScript正则表达式迷你书","url":"/2018/03/19/BOOK/JavaScript正则表达式迷你书/","content":"\n# 两种模糊匹配\n如果正则只有精确匹配是没多大意义的，比如 /hello/，也只能匹配字符串中的 \"hello\" 这个子串。\n\n正则表达式之所以强大，是因为其能实现模糊匹配。\n而模糊匹配，有两个方向上的“模糊”：横向模糊和纵向模糊\n\n## 横向模糊匹配\n一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。\n其实现的方式是使用量词。譬如 {m,n}，表示连续出现最少 m 次，最多 n 次。\n## 纵向模糊匹配\n\n一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种\n可能。\n其实现的方式是使用**字符组**。譬如 [abc]，表示该字符是可以字符 \"a\"、\"b\"、\"c\" 中的任何一个。\n\n# 字符组\n需要强调的是，虽叫字符组（字符类），但只是其中一个字符。\n## 范围表示法\n[a-z]\n## 排除字符组\n[^a-z]\n## 常见的简写形式\n\\d === [0-9]\n\\D === [^0-9]\n\\s === [\\t\\r\\n\\v\\f] :空白符,比如去除字符串中的所有空格\n\\S === [^\\t\\r\\n\\v\\f]\n\\w === [a-zA-Z0-9_]:单词字符\n\\W === [^a-zA-Z0-9_]\n. === [^\\n\\r\\u2028\\u2029]:通配符,淡出不包括换行符\n...\n\n# 量词\n{m,n}\n{m,}\n{0,n}\n?\n+\n*\n\n# 贪婪匹配与惰性匹配\n\n\n\n# 正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。\n\n\n#位置\n位置（锚）是相邻字符之间的位置\n\n## 如何匹配位置呢\n在 ES5 中，共有 6 个锚：\n^、$、\\b、\\B、(?=p)、(?!p)\n\n\n# ^,$\n^（脱字符）匹配开头，在多行匹配中匹配行开头。\n$（美元符号）匹配结尾，在多行匹配中匹配行结尾。\n\n# \\b 和 \\B\n\\b 是单词边界，具体就是 \\w 与 \\W 之间的位置，也包括 \\w 与 ^ 之间的位置，和 \\w 与 $ 之间的位置。\n\n# (?=p)、(?!p)\n(?=p)，一般都理解成：要求接下来的字符与 p 匹配，但不能包括 p 匹配的那些字符。\n而在本人看来，(?=p) 就与 ^ 一样好理解，就是 p 前面的那个位置。\n\n# JavaScript 正则表达式中，都有哪些结构呢？\n字符字面量、字符组、量词、锚、分组、选择分支、反向引用。","categories":["BOOK"]},{"title":"JavaScript高级程序设计","url":"/2018/03/19/BOOK/JavaScript高级程序设计/","content":"\n# defer && async\n\ndefer:延迟脚本,表明脚本在执行时不会影响页面的构造。这个属性的用途是表明脚本在执行时不会影响页\n面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在`<script>`元素中设置\ndefer 属性，相当于告诉浏览器立即下载，但延迟执行。\n\nasync:。同样与defer 类似，async 只适用于外部脚本文件，并告诉浏览器立即下载文件。但与defer\n不同的是，标记为async 的脚本并**不保证按照指定它们的先后顺序执行**\n\n所以，建议添加deffer\n\n\n\n#frameset\n\n\n","categories":["BOOK"]},{"title":"javascript权威指南","url":"/2018/03/19/BOOK/javascript权威指南/","content":"\n","categories":["BOOK"]},{"title":"HTML5与CSS3权威指南","url":"/2018/03/19/BOOK/HTML5与CSS3权威指南/","content":"\n# 新增标签和属性\n- section\n- aside\n- article\n- header\n- hgroup:标题组合\n- footer\n- nav\n- figure:独立流内容\n- video\n- audio\n- embed:用来插入多种多种多媒体\n- mark\n- progress\n- time\n- command:命令按钮\n- details\n- datalist:可选数据列表，配合input使用，很有用\n    ```\n    <input type=\"text\" list=\"list1\">\n    <datalist  id=\"list1\">\n        <option value=\"1\">1111</option>\n        <option value=\"2\">2222</option>\n        <option value=\"3\">333</option>\n    </datalist>\n    ```\n- output：输出\n- source:媒介元素\n- menu\n- address\n- \n- \n- \n- \n- \n\n# 全局属性\n- contentEditable\n- hidden\n- tabindex\n\n\n# 新增属性\n- form\n- formaction\n- formmethod\n- autofoucs\n- autocomplete\n- ","categories":["BOOK"]}]