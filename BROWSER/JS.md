---
title: BROWSER-JS
categories: 
- BROWSER
---

浏览器收到的js代码是一个字符串，但是通过这些字符串却可以操作Dom，进行计算，浏览器怎么实现的？

简单流程就是

- 解释:将字符串变成`javascript语句`
- 预处理:
- 执行:



# 解释

js是一种弱类型的解释形语言

和java，C/C++，不一样，不用提前编译

但是js和java又有相同的地方，就是java和js这两种语言，都不是直接在计算机上跑的，都是在对应的`虚拟机`上跑的

```
.java->.class(字节码)-----|------>JVM
```
js也是类似的流程

```
.js-------|------>字节码->js引擎
```

不同的是`编译的时机`


js具体编译的流程:

- 词法分析，变成对应的一个个js中的`符号`
- 语法分析，通过符号，进行语法分析，构建一个`语法树`
- 使用编译器，将语法树编译成字节码

字节码是只能跑在虚拟机里面的，这里的虚拟机就是`js引擎`

----------------
其实还可以直接将语法树转变成`机器码`的

机器码是直接跑在真实的计算机上面的，没有了`虚拟机`这一层约束，自然速度更快

V8之前就这么做的，直接将语法树变成了机器码

而其他js引擎基本都是使用字节码的

但是后来V8发现，使用机器码速度自然更快，但是机器码会占用更多的内存，复杂度高等原因，后来也还是改用`字节码`了


### JIT

这里还有一个问题，java是编译完成后，再运行,`一次编译，到处运行`

js则是在运行的时候，由js引擎编译成字节码后，再运行，`每次都得重新编译`

JIT(just in time compile，即时编译)

也就是遇到`一个语句`就编译`一个语句`，将计算结果缓存起来，其他的不管

> 注意，是按照语句一个一个来，不是一行一行，一个语句可能多行

由于JIT速度会加快动态语言的编译速度，所以大多数动态语言都采用了这种技术

# 预处理

js特有的一个过程，其他语言几乎看不到

比如封号的补全，变量提升等工作就在这个步骤完成

其实这个阶段不应该存在，编译完成后就应该是最终结果

# 执行

执行阶段是这三步中最复杂的了，因为这一步要`实现javascript语法`

这里涉及到很多概念

- 执行环境栈(execution content stack)
- 全局执行环境(execution context,EC)
- 变量对象(varible object,VO)
- 活动对象(active object,AO)
- 作用域(scope)
- 作用域链(scope chain)


## 执行环境栈

js，或者受所有的语言，都是按照从左到右，从上到下来运行的

这是怎么实现的？

比如:
```
var a=1;
var b=a+2;
console.log(b);
```
人们的普通的习惯就是从左到右，从上到下

js引擎是用C++写的，C++是可以操作内存的

思路是这样的

- 一个语句分为一个item
- 将所有的item从上到下，逐个压入一个`栈`类型的数据结构中
- 然后从弹出一个栈，进行执行，逐个弹出，逐个执行
- 当栈为空之后，也就表述程序执行完成

js在运行的时候，也是按照这个流程走的

js引擎创建了一个stack，将语句压入，从上到下压入，

执行js代码，就是弹出一个语句，执行一个语句，以此类推，当这个stack为空了之后，就表示js执行完毕

## 全局执行环境(EXCUTION CONTENT)

因为js语法中有一个全局作用域的东西，也就是说，在js执行的过程中，全局作用域的数据，都是可以被访问到的

所以，js引擎针对这种语法，需要有特别的实现，实现方式就是创建一个`线性表`(具体啥类型的线性表，不清楚)

里面保存着全局变量，全局函数

将EC压入执行环境栈，放在最底下,这个`上下文栈`也被称为`Global EC`

这样就可以实现，js在运行的过程中，全局变量都是可以访问到的

---------------
当然，不仅仅全局变量会产生`上下文栈`,一共有三种类型

- global
- function
- eval

函数也会产生一个`上下文栈`

执行eval函数，也会产生一个`上下文栈`

## 变量对象(VO)

如果是global excution context ，里面存放的是全局变量，全局函数

如果是function excution context ，里面存放的是局部变量，布局函数

但是如果仅仅存储这些，那么作用域链，闭包等这些功能就无法实现，所以，存储的东西不止这些

一个EC，存储的内容主要有三部分

- 变量对象(Variable object，VO)
- 作用域链(Scope chain)
- this:指向这个EC，也就是自身


```
var a=1;
function F1(){
    var b=2;
    function F2(){
        var c=3;
    }
}
```

现在，js进去可以创建一个类似这样的数据结构

```
ECSTACK=[
    EC(F1)={
        VO:{
            arguments:[],
            b=2,
            F2=function(){...},
            SCOPE_CHAIN(FN2)=[THIS,EC(F1)]
        }
        SCOPE_CHAIN(FN1)=[THIS]
        THIS:EC(F1)
    },

    GEC={
       VO={
           A=1;
       },
       SCOPE_CHAIN:GEC,
       THIS:GEC
    }  
]
```
### 总结
variable object，也是js引擎创建的一个数据结构，存放的是自己相关的数据

然而，一个执行栈，仅仅保存这个VO是不够的，无法满足js语法需求，还需要保存`scope chain`,和`this`





## 活动对象(ACTIVE OBJECT)
js在刚开始还没执行代码的时候，仅仅会创建一个VO,就是全局VO，比如函数的VO只有在运行的时候创建

AO就是在执行过程中，创建的VO

因为是运行的时候创建的，所以AO会在`上下文执行栈`的顶端


## 作用域

js语法中规定，内部函数可以访问外部函数的变量

js引擎就需要提供这种需求

解决方式就是在`EC`中添加一个数据`SCOPE CHAIN`

里面记录这所有的自己所处的换进

如果是内部函数，这个链条就应该是`GLOBAL SCOPE->PARENT SCOPE->THIS`

## 作用域链

作用域链，不是创建完成后就一成不变了

如果一个函数执行完成后，如果内部资源没有被引用的话，那么这个函数对应的`EC`会被删除掉，scope chain自然也会被删除掉(垃圾回收机制会自动删除)

----------
但是如果函数内部的资源被`引用`了，那么函数即使执行完毕后，对应的EC也不能删除(因为还以有用)

这种情况就是`闭包`

只有在程序执行完成后，或者引用没有了，垃圾回收机制才会回收

# 垃圾回收

通过以上的机制，可以实现js的语法

上面可以看到，EC的删除与否，取决于是否被引用

引用了，EC会保留，不引用了，EC会删除

js引擎是怎么判断是否被引用的？

思路很简单给每一个资源，做一个标记，或者记录其引用的次数


如果次数是0，js引擎就进行回收

这就需要js引擎，每隔一段时间，就需要来检查一次引用次数









# LINKS
- [https://dailc.github.io/2018/03/12/whenyouenteraurl.html](https://dailc.github.io/2018/03/12/whenyouenteraurl.html)
- [http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html](http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html)
-[https://www.cnblogs.com/onepixel/p/5090799.html](https://www.cnblogs.com/onepixel/p/5090799.html)