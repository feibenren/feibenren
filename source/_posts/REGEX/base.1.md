---
title: base
categories: 
- REGEX
---

正则方法
- regex.test(str)
- regex.exec(str)

字符串方法
- string.match(regex)
- string.search(regex)
- string.replace(regex)
- string.split(regex)

修饰符
- g(global)修饰符:全局匹配（默认情况下，第一次匹配成功后，正则对象就停止向下匹配了），默认false
- i(ignore case)修饰符：忽略大小写（ignorecase），默认false
- m(multi lines)多行搜索，默认false


# 正则表达式由两种基本字符类型组成
- 原意文本字符:
- 元字符:比如\d,\w,+?*~


# 预定义模式
- . [^\r\n] 回车换行以外的所有字符
- \d 匹配0-9之间的任一数字，相当于[0-9]。digit
- \D 匹配所有0-9以外的字符，相当于[^0-9]。
- \w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。word
- \W 除所有字母、数字和下划线以外的字符，相当于/[^A-Za-z0-9_]/ 。
- \s 匹配空格（包括制表符、空格符、断行符等），相等于[\t\r\n\v\f]。whitespace
- \S 匹配非空格的字符，相当于[^\t\r\n\v\f]。


# ^，不同的位置有不同的意思
- 在[]号中，表示取反
- 不在[]中，表示开头

# $也同上


- \b 匹配词的边界。
- \B 匹配非词边界，即在词的内部。


# 特殊字符
- \n 换行键 
- \r 回车键 
- \t 制表符tab  



\r,\n,\r\n 有什么异同

[https://zhidao.baidu.com/question/386412786.html](https://zhidao.baidu.com/question/386412786.html)

并没有异同。
\r 和 \n 好像都是以前的那种打字机传承来的。
\r 代表回车，也就是打印头归位。
\n代表换行，就是走纸。
linux只用\n换行。
win下用\r\n表示换行







# 括号
- []:one of，只要匹配其中的一个即可
- ():group
- {}:times 循环次数


# 边界
- ^ 以XXX开始
- $ 以xxx结束
- \b 单词边界
- \B 非单词边界


```
var result = "I\nlove\njavascript".replace(/^|$/gm, '#');
console.log(result);


/*
#I#
#love#
#javascript#
*/

```


```
var result = "I\nlove\njavascript".replace(/^|$/g, '#');
console.log(result);


/*
#I
love
javascript#
*/

```
添加了m,就表示这是多行匹配模式，没有添加m，就表示单行匹配模式


# 量词
- ? === {0,1} 0或者一次
- + === {1,} 1或多次
- * === {0,} 0或多次
- {n}
- {n,m}
- {n,}

注意

```
asdf{3}
```
表示的意思是，匹配asd，然后f连续出现3次
也就是说，量词默认是作用于紧紧相连的单词的，不相连的不作用于，因为我根本不知道我需要作用于到哪里啊

如果想好实现asdf连续出现3次，怎么办？
需要分组

```
(asdf){3}
```

注意:{,2}表示最多两次，是错误的，这样表示的就是字符串 '{,2}'
应该{0,2}表示最多两次

# 贪婪模式&非贪婪模式
正则是默认贪婪模式
```
\d{3,6}

12345678910

```
比如这样，正则默认是这样匹配的
123456，78910
正则会最先匹配6个连着的，然后是5个...
但是，加入我想实现最先匹配3个，然后是4个...，怎么办？

```
\d{3,6}?

12345678910

```
123,456,789
10不够3个，就不匹配

非贪婪模式，很简单，只要在量词后面添加?即可

# 分组
()可以达到分组的功能，使量词作用于分组
```
(abc){3}
```
分组还有一种情况
```
aa(a|b)bb
```
这样的话，就表示可以匹配到aaabbb,aabbb,

如果不加的话
```
aaa|bbb
```
这样就表示，匹配到的东西就是,aaa,bbb，性质就完全不一样了


# 分组的反向引用
```
2018-3-14
替换成
14/3/2018
```
怎么做，这就有点像变量的概念了

```
'2018-3-14'.replace(/(\d+)-(\d+)-(\d+)/,'$3-$2-$1')
```
$1,$2,$3,表示的就是第一个分组，第二个分组，第三个分组，这样我就可以自由替换了

如果我不想捕获分组，那么只需要加上'?:'即可

```
(?:\d+)-(\d+)-(\d+)
```
注意，必须在(的后头添加，否则，?:就表示其他意思了

```
(\d+?:) 
```
这样表示的就是\d一个或多个，然后加上一个字符:


# 前 
就是说正则在匹配的时候，是从前往后开始解析的，这叫做前

# 后
和前相反，从后往前解析

# 前瞻
正则在匹配到规则的时候，向前检查是否符合断言(注意，断言不是正则匹配的一部分，例子中有说明)


# 后顾
和前瞻正好相反
js不支持后顾，不说

## 正向前瞻|肯定前瞻， exp(?=assert)
符合某个断言的前瞻
## 反向前瞻|否定前瞻，exp(?!assert)
不符合某个断言的前瞻

例子
```
\w(?=\d)
```
意思就是说，一个字符后面，必须得是数字，
注意，这个正则匹配到的仅仅是字符，不包含断言，也就是数字
这就是肯定前瞻


```
\w(?!\d)
```
和上面例子正好相反，字符后面不能是数字
这就是否定前瞻










# 范围类
[0-9]
[a-zA-Z]
[a-z]:必须放到[]中，因为只有放到[]中，才能表示其中一个，放到()中，那么久成了一个'a-z'的字符串了

注意，只有这种情况下，才表示一个范围，如果不是这样连着的，那么久表示三个简单的字符了



# ^ 非
[#abc]: 匹配字符串中的所有的字符，除了a,b,c这三个字符，这三个字符不一定连在一起


常见情况
- 字符串里面可能有空格，回车，我想去掉
- 在字符串中查找字符串`abc`，如果存在，就都替换成`ABC`
- 查找某个字符串中是否含有`abc`
- 匹配数字
- 匹配电话号码
- 匹配邮箱
- 确定字符串的大小是否在某个区间

在姓名列表中，将王性别的都给去掉

```
var str=`
王兵
韦杰
赵某某
钱某某
王某某
孙某某
`;

var arr=str.split('\n');
console.log(arr);
var res=arr.filter(function(val,index,arr){
   if( val.search(/^王/) >-1 ){
        return false;
   }else{
       return true;
   }
}).join('\n');
console.log(arr);
console.log(res);

```

我们也可以将这些反斜杠代码用在方括号中。例如，[\d.]匹配任意数字或一个句号。但是方括号中的句号会失去其特殊含义。其他特殊字符也是如此，比如+。


脱字符（^）


分组是提取部分字符串的实用特性