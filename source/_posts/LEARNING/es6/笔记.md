---
title: 笔记
categories: 
- LEARNING
- ES6
tags:
- js
- es6
---

# ES6 声明变量的六种方法
- var
- function
- let
- const
- import
- class



# 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值

# 解构赋值
- 数组解构赋值
- 对象解构赋值
- 字符串解构赋值
- 函数参数的解构赋值

```
//数组解构赋值
let [a, b, c] = [1, 2, 3];
```

```
//对象解构赋值
let data={
    name:'xxx',
    title:'asdf',
    sex:'zdsf'
}
let {name,title}=data;
/////////////
let data={
    name:'xxx',
    title:'asdf',
    sex:'zdsf'
  }
  let {name:Name,title:Title}=data;
  console.log(Name,Title);
```
## 这两种写法是等价的，换句话说，本质上是赋值给val，不是给可以的


# 解构赋值的作用
- 交换变量的值
- 从函数返回多个值，可以方便的赋值
- 函数参数的定义，可以将一组参数与变量名对应起来
- **提取JSON数据**
- 函数参数的默认值
- 遍历Map结构
- 输入模块的指定方法


```
//遍历Map结构
const map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
  console.log(key + " is " + value);
}
```

# 什么时候解构会不成功？
- 总的说就是两边的解构不一样


# 默认值生效的条件是，对象的属性值严格等于undefined。

    

# Number.parseInt(), Number.parseFloat()

ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。


# 指数运算符
```
2 ** 2 // 4
2 ** 3 // 8


let a = 1.5;
a **= 2;
// 等同于 a = a * a;
```

## 这是参数默认值情况吗
```
function foo({y = 5}) {
  console.log(y);
}
```
**不是，这是解构赋值**
# 如果一个函数的参数是一个对象，或者是一个数组，那么这一定是解构赋值

```
function foo({y = 5}={}) {
  console.log(y);
}
```
这种情况就是解构赋值和参数的默认值结合的情况了


#函数的 length 属性:该函数预期传入的参数个数
将返回没有指定默认值的参数个数
```
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
(function(...args) {}).length // 0
```

# 参数作用域
```
var x = 1;

function f(x, y = x) {
  console.log(y);
}

```
f(1)会有什么结果？？？
1

一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。



# 箭头函数牛逼的地方：函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。

```
function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}

var id = 21;

foo.call({ id: 42 });
```


