---
title: C语言杂记
categories: 
- C
---

# 在线c环境
[https://studio.dev.tencent.com](https://studio.dev.tencent.com)

# 指针

```
int main(){
    int a=1;
    print("&a:%p",&a);//&,获得a变量的内存地址，也就是指针
    print("*&a:%p",*&a);//*&,获得内存地址中存储的数值，和直接打印a效果一样
    return 0;
}
```

# 单引号，双引号的不同
单引号和双引号在C语言中不一样，不能混用

单引号用来标识单个字符，双引号标识字符串



# const  #define 

`#define` 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 #define 不为宏名分配内存，而 const 也不为常量分配内存，怎么回事呢，其实 const 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！

# 存储类

auto 
register
static
extern


# 变量，地址，指针

变量：存储数值的容器
地址：变量的地址(变量在内存中的存储地址)
指针: 存储地址的容器



# 字符串常量和字符数组


# 整数是如何存储的？

C中，整数通过补码来存储，使用补码，可以统一加法和减法


# 什么是32位系统，什么是64位系统

这需要从cpu的寄存器说起

register 分为很多种，这里直说地址寄存器，专门用来存放内存对应的地址的寄存器

1、cpu输入输出的数据，经过寄存器，再流入内存

内存可以做的很大，但是速度慢，寄存器就是两者之前的代理

寄存器存储的仅仅是内存的地址，需要的时候找到地址，复制内存地址中的数据到数据寄存器中，等待cpu使用

 · 

register一次只能给cpu 1byte的数据，那么cpu一次只能处理1byte的数据

如果是2byte，那么处理能力就翻倍



地址寄存器存放数据的大小，叫做带宽，一般是32位或64位的，也就是说，一次可以存放32bit或64bit的内存地址

根据这个指标，cpu分为32位cpu和64位cpu

32bit的内存地址，最大也就4G，这就是为什么32位的cpu只能支持4G的内存的原因

2、操作系统也会跟着CPU走

试想CPU一次处理64bit数据，但是我的操作系统设计成一次只能处理8bit数据，那么CPU的新能就无法发挥

比如C中的int数据类型

在16位的操作系统中，使用2byte来表示

在32位系统中，使用4byte来标示

这样就会导致，int表示的范围大了很多，好处大大的








