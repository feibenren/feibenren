---
title: C语言杂记
categories: 
- C
---

# 在线c环境
[https://studio.dev.tencent.com](https://studio.dev.tencent.com)



# 存储类

auto 
register
static
extern


# 变量，地址，指针,变量名，引用

变量：一段连续的内存空间
地址：变量的地址
指针: 存储地址的容器
变量名:一段连续的内存空间的别名，方便程序使用

引用:C++中的概念，C没有，引用本质也是一段连续内存空间的引用，和变量名一个意思，所以也叫做变量的别名，但是在C++中，引用有特殊功能



# 字符串和字符数组
先说数组，数组就是一串连续的可用内存，重点是连续

数组可以存放int，double等数据类型

字符数组就是专门存放字符的数组，例如

```
#include <stdio.h>
int main() {
	char addr[] = {'a','b','c'};
	printf("%d\n", sizeof(addr));//3
	getchar();
	return 0;
}
```
这样的结果就是3,


字符串的定义就是一连串的字符，结尾使用\0结束，表示方式有很多

```
#include <stdio.h>
int main() {
	char techang[] = "eat";//不指定数组长度，后面直接赋值为字符串，系统会自动给数组添加\0
    char name[10]={'h'};//这种设置的方法，系统也会自动补齐剩余的都为0
    printf("%d\n", sizeof(techang));//4
    printf("%d\n", strlen(techang));//3 strlen不统计0
	getchar();
	return 0;
}
```
也可以手动添加结尾标志
```
char job[] = { 'c','o','d','e','\0' };
```
可以看到，一个字符串本质上就是一个字符数组，字符数组的名字是一个指向第一个元素的指针，那么这个指针就可以赋值给一个指针，如下，系统可以识别如此赋值方式
```
char * hobby = "music";
```







# 整数是如何存储的？

C中，整数通过补码来存储，使用补码，可以统一加法和减法




# 什么是32位系统，什么是64位系统

这需要从cpu的寄存器（register ）说起

register 分为很多种，这里直说`地址寄存器`，专门用来存放内存对应的地址的寄存器(内存每个bit都有一个唯一的编号)

1、cpu输入输出的数据，经过寄存器，再流入内存

内存可以做的很大，但是速度慢，寄存器就是两者之前的代理

寄存器存储的仅仅是内存的地址，需要的时候找到地址，再去复制内存地址中的数据到数据寄存器中，等待cpu使用



例如，register一次只能给cpu 1byte的数据，那么cpu一次只能处理1byte的数据

如果是2byte，那么处理能力就翻倍



地址寄存器存放数据的大小，叫做带宽，一般是32位或64位的，也就是说，一次可以存放32bit或64bit的内存地址

根据这个指标，cpu分为32位cpu和64位cpu，位数越多，寄存器能对应的地址越多，寄存器能够使用的内存也就越大

32bit的内存地址，最大也就4G，这就是为什么32位的cpu只能支持4G的内存的原因

2、操作系统也会跟着CPU走

试想CPU一次处理64bit数据，但是我的操作系统设计成一次只能处理8bit数据，那么CPU的效能就无法发挥

比如C中的int数据类型

在16位的操作系统中，使用2byte来表示

在32位系统中，使用4byte来标示

这样就会导致，int表示的范围大了很多，好处大大的


综上，32位系统，就是32位cpu+32位操作系统






# char类型的本质
char类型本质就是一个占用一个bit位的整数类型,一共存放	-128 到 127 或 0 到 255个数

为什么ascii一共有126个字符？不能更多呢？

就是因为char类型最多表示127个字符而已

所以，在c中，可以这样赋值

```
#include <stdio.h>
int main() {
	char name = 'a'; 
	name = 97;//表示ascii中97对应的符号，b
	printf("%c\n", name);
	getchar();
	return 0;
}
```


# 随机数

C语言中有两个函数，rand()和srand();函数来产生,这两个函数都在`<stdlib.h>`中

1、rand()函数，可以产生一个随机数

```
#include<stdio.h>
#include<stdlib.h>

void main()
{
	printf("%d\n", rand());
    printf("%d\n", rand());
    printf("%d\n", rand());
	getchar();
}
```
但是可以发现，每次运行的时候，rand()产生的随机数都一样,为什么？

rand()函数其实是根据一个seed来产生的，具体原理不说，只要这个seed一样，那么每次都会产生相同的数，这个数虽然是随机的，但是每一都一样，那这可就不能叫做随机了，不设置seed的话，默认值是1

如何修改seed？

使用srand()

```
#include<stdio.h>
#include<stdlib.h>
void main()
{	
	srand(7);//指定一个特定的整数，
	printf("%d\n", rand());
	getchar();
}
```

可以发现和上一次的一样，但是每次运行，这个数还是固定的

那么需要产生一个每次运行都不一样的整数，这个数可以使用时间戳

```
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
void main()
{	
	srand((int)time(NULL));
	printf("%d\n", rand());
	getchar();
}
```
可以发现每次运行的时间都不一样


# 递归

递归就是下山和上山

原点就是山顶

终止条件就是山底



# 静态库(lib)和动态库(ddl)





# 变量名的本质
一段连续内存空间的别名

程序通过变量来申请和命名内存空间

不是变量名读写数据，而是变量名指向的内存空间读写数据


```
int a=1;
```
如上，上面的代码需要两个内存空间来存储，一个是存储变量名的空间，一个是栈区中存放int 类型的变量空间




# 内存四区

内存被分为好多区块，不能相互读取，比如操作系统占用的的内存空间，其他程序不允许访问

针对应用程序来说，内存被分为四个区块

```
size a.out

text    data     bss     dec     hex filename
1198     560       8    1766     6e6 a.out
```
可以查看到这个可执行文件需要占用的内存空间大小

主要分为

- 栈区:
- 堆区
- 代码区
- 静态区

## 代码区
程序在执行前，程序会被加载到代码区，加载后就不能修改了

同时也是共享的，可以被其他程序访问

总的来说就是`只读，共享`


## 栈区
栈区是有最大空间限制的，一般是1M，所有的局部变量，函数参数，函数返回值等，

这块区域程序是实时加载和释放的，所以无法长久保存，想要长久保存，需要将变量放到静态区

## 堆区

栈区空间有限，所有的程序可能不够用，堆区空间则很大，内存绝大部分空间都是堆区，

c程序如果处理图片，视频等，需要通过申请堆区来使用，栈区根本不够用

堆区可以理解为 公共的，所有程序可以申请的，足够大的内存空间

## 静态区
程序中的全局变量，静态变量，常量都被放到了静态区

可执行程序在`size`的时候，就有data，bss区域的大小，可以看到这个区域在执行的时候，也是固定大小的，不能修改

这个区可以细分为三个区

- DATA区:初始化数据区,`static a=2;cont b=3;`
- BSS区:未初始化数据区,`static a;`
- 常量区:常量保存的区域,`cont int c=4;`

总的来说，这里面的数据相对保持静态，和栈区不一样


# 指针到底应该怎么写?

```
int a=1;
int *b=&a;
int* b=&a;
```
指针的两种写法都正确，*和谁在一起没有规定，但是那种更好？

如果针对普通变量来说，无所谓

但是

```
int a = 1;
const int *p = &a;
p = &b;
```
通过const修饰的到底是什么来看，const修饰的应该是 `int`,而不是 `int*`

同样，参照C++中的概念

```
int a=1;
int &b=a;
```
只要是一个变量名称前面加上一个`&`就表示引用，而不表示普通的变量名称

同样，也可以这样理解指针

```
int a=1;
int *p=&a;
```
只要是一个普通变量名前面加上一个`*`就表示指针，而不表示普通变量了

综上，应该这样写
```
int *p=NULL;
```

可以推导出，在C/C++语言中，只是通过`int,char`等这种关键字是无法确定这个变量到底是什么的，还需要看看`*,&`才可以确定




# const

const 修改普通变量，不能通过变量名进行修改，但是可以通过地址修改

```
int a=1;
int *p=&a;
*p=2;
printf("%d",*p);//2
```

可以看到，找到一个数值，有两种方法，一种是指针，一种是变量名


涉及到指针，这里就有意思了


```
int a=1;
int b=2;
const int c=3;
const int *p=&a;
p=&b;//ok
*p=4;//err

```

将*p当作一个整体就好理解了

和上一行一样，const修饰的普通变量c

但是这一行修饰的就是*p,*p这个整体无法修改,所以 `*p=4;`这种操作就会报错

但是没有规定 p不能修改，所以 `p=&c`这种操作就可以

还有一种情况，语法也可以支持

```
int a=1;
int * const p=&a;
```
这样也就就好理解了

```
int (* (const p))
```
const 修饰的p,p无法修改，但是但是可以修改p对应内存的数据

综上，如果想要控制住一个指针变量，需要这样写

```
int a=1;
const int * const p=&a;
```