---
title: base
categories:
  - REGEX
---

# REGEX

正则(regular express:规则表达式)是描述字符模式的表达式

# 单个字符

简单情况，匹配单个字符 a,正则可以直接写`/a/`

但是还可以匹配一些特殊字符，比如回车，tab，那么就需要使用转义,比如 tab===`/\t/`，回车===`/\r\n/`

常见的有:

- tab ===`/\t/`
- 回车 ===`/\r\n/`

在正则中，一些标点符号都代表特殊意义，比如+表示一个到多个的重复，不表示加法运算的加号，如果需要表示加减运算的加号，那么需要这样表示: `/\+/`

- `/\+/`
- `/\*/`
- `/\?/`

# Character classes

如果匹配 **某类字符**，那么就需要使用 `[]`来匹配某类字符，比如`[abc]`,表示匹配字符 a 或 b 或 c,

`[^abc]`就表示匹配的字符不能是 a,b,c 中的任何一个


**但是这仅仅是匹配一个字符**

罗列所有可能的匹配字符可能会很麻烦，比如匹配数字，可以这样写:`[0123456789]`,可以简写`[0-9]`,同样，还有`[a-z]`等

还可以进一步简化，比如`[0-9] ===  \d`

常见的简写形式有:

- `\d ===[0-9]`:数字
- `\D ===[^0-9]`:非数字
- `\s ===[\t\r\n]`:空白字符(回车,tab,空格)
- `\S ===[\t\r\n]`:非空白字符
- `\w === [a-zA-Z0-9_]`:单词字符
- `\W === [^a-zA-Z0-9_]`:非单词字符
- `. === [^\r\n]`:任何字符，除了换行符

# Quantifiers(量词)

以上仅仅是匹配单个字符，如果需要匹配多个字符，那么就写多个匹配字符，比如`/aa/`,表示匹配 ab 这个 **字符串**

如果要匹配 10 个 a，那么就应该是`/aaaaaaaaa/`,

这样就很麻烦，可以简写成`/a{10}/`

还可以匹配数量不一定的字符，如`/a{3,5}/`

同样，正则还有几种简写方式:

- `* ==={0,n}`
- `+ ==={1,n}`
- `? ==={0,1}`

# 贪婪模式(Greed mode) && 懒惰模式(Lazy mode)

因为量词数量不一定，就带来一个问题，比如`/a{3,6}/`,会怎么匹配

会尽可能多的匹配，也就是先满足6个连续的a，没有的话，就找5个连续的a，以此类推，这叫Greed mode 

与之对应的是Lazy mode,格式是`{m,n}?`


# Groups & References

有了量词，那么就有这么一个问题

匹配`abc`这三个字符 3-5 次，就是`/abc{3,5}/`

然而，这表示的是 c 出现 3-5 次，不是 abc 这个字符串，因为正则不知道 abc 是一组，所以，默认就是匹配单个字符

需要使用()，表示 abc 这三个字符串是一个整体,`/(abc){3,5}/`

使用 group，还有一个好处，就是可以获得某个分组的引用，比如`/(\d{4})-\d{2}-\d{2}/`,可以在函数中使用`$1`表示正则中的第一个group

还有一种特殊情况，就是不希望被引用(不能使用`$n`来获取数据),可以使用`(?:p)`来表示


# 或

比如想要匹配 apple 或者 orange,那么可以:`/apple|orange/`，

如果针对单个字符，有更简单的方式，比如`[ab]`，就表示 a 或 b

# LOOK

有时候需要匹配字符 g 前面的 a,注意:匹配的是 a，不是 ag

这个时候就需要做两件事：确定 g 的位置，然后匹配 a

需要使用特定规则`match(condition)`,

注意，(condition)不会出现在匹配结果中,它仅仅是一个匹配条件，获得的是match


根据(condition)和match的位置的不同，分为lookahead,lookbehind(针对condition而言)


- `match(?=condition)`:get match followed by condition(lookahead:朝前看)
- `match(?!condition)`:get match not followed by condition(negative lookahead)
- `(?<=condition)match`:get match follow by condition(es6才支持)(lookbehind:朝后看)
- `(?<!condition)match`:get match not follow by condition(es6才支持)(negative lookbehind)

在正则中，还有一些元素表示匹配位置

# Anchors

- `^`:Matches the beginning of the string, or the beginning of a line if the multiline flag (m) is enabled. This matches a position, not a character.
- `$`:同上
- `\b`&& `\B`:Matches a word boundary position between a word character


# flag

正则有些默认规则,比如，大小写敏感，匹配到一个就不再继续匹配，然而有时默认规则不符合我们的预期，可以通过falg来改变默认规则(以下规则默认都是false)

- i:不区分大小写
- g:全局匹配(匹配所有)
- m:多行模式(开启多行匹配模式，默认单行匹配模式,只对^,$有影响)

# 常见问题



# 方法


## 正则对象
### regex.test(str)
### regex.exec(str)

## 字符串方法

### String.search(regex)
### String.match(regex)
### String.search(regex):
Finds the first substring match in a regular expression search

### String.replace(regex)
### String.split(regex)






# ^，不同的位置有不同的意思

- 在[]号中，表示取反
- 不在[]中，表示开头




# 特殊字符

- \n 换行键
- \r 回车键
- \t 制表符 tab

\r,\n,\r\n 有什么异同

[https://zhidao.baidu.com/question/386412786.html](https://zhidao.baidu.com/question/386412786.html)

并没有异同。
\r 和 \n 好像都是以前的那种打字机传承来的。
\r 代表回车，也就是打印头归位。
\n 代表换行，就是走纸。
linux 只用\n 换行。
win 下用\r\n 表示换行




# 分组的反向引用

```
2018-3-14
替换成
14/3/2018
```

怎么做，这就有点像变量的概念了

```
'2018-3-14'.replace(/(\d+)-(\d+)-(\d+)/,'$3-$2-$1')
```

$1,$2,$3,表示的就是第一个分组，第二个分组，第三个分组，这样我就可以自由替换了

如果我不想捕获分组，那么只需要加上'?:'即可

```
(?:\d+)-(\d+)-(\d+)
```

注意，必须在(的后头添加，否则，?:就表示其他意思了

```
(\d+?:)
```

这样表示的就是\d 一个或多个，然后加上一个字符:






# 范围类

[0-9][a-za-z]
[a-z]:必须放到[]中，因为只有放到[]中，才能表示其中一个，放到()中，那么就成了一个'a-z'的字符串了



# ^ 非

[^abc]: 匹配字符串中的所有的字符，除了a,b,c这三个字符，这三个字符不一定连在一起

# 常见问题

## (a-z) , [a-z]
- (a-z):a,-,z三个字符组成的group
- [a-z],所有的小写字符

## [^abc]
可能会有歧义,非a加bc,还是非a加非b加非c，

none of abc，不能是abc三个字符中的任何一个字符

[]字符类只能匹配一个字符

## [\w+] 表示什么意思

\w可以有1到多个?

不会，还是[]的问题，[]只能匹配单个字符，在[]中，所有的量词都量词的意义，变成了普通的字符串




# 常见需求



### 匹配手机号码

满足的条件:
- 手机号一共11位数
- 第一位是1
- 第二位可能是35789,其中的任何一位
```
/1[35789]\d{9}/
```
### 匹配邮箱

满足的条件:
- 一定带有@符号
- 邮箱不能含有空白字符
- ...

```
/\w+@(\w\.(com|net))+/
```

### 长度为8-10的用户密码（以字母开头、数字、下划线）
```
[a-zA-Z_]\w{7-9}
```

### 求非负整数


### 匹配正整数

### 非正整数


### 负整数
### 整数
### 非负浮点数
### 正浮点数 
### 非正浮点数

### 验证输入只能是汉字
^[\u4e00-\u9fa5]{0,}$

### URL地址验证
```
https?://\w+\.(com|cn|net)(/\w+/)*(\w+\.\w+)*
```

### 身份证号验证
- 6位表示地区
- 8位表示生日
- 4位表示num,最后一位可能是x

```
\d{6}-----[12]\d{3}----\d{3}[\dx]
```


### 获得网页字符串中的所有图片地址




我们也可以将这些反斜杠代码用在方括号中。例如，[\d.]匹配任意数字或一个句号。但是方括号中的句号会失去其特殊含义。其他特殊字符也是如此，比如+。

脱字符（^）

