---
title: TCP
categories:
- NETWORK
---

# base

传输层的下面是网络层，上面是应用层

这层的主要目的就是端口和端口之间的数据通信

在这一层传输数据，有一个问题，`网络层不稳定`

其实网络层，链路层，物理层都有不稳定的因素

- 物理层:断电，线路破坏
- 数据链路层:找不到对应的接收方
- 网络层:数据传输超时

所以，传输层也就更不稳定

所以这些层在数据传递的时候，都会有一定的验错机制

如果传输层不提供一种稳定的传输方式的话，那么应用层中的那些协议就无从谈起


# UDP

先说不稳定的传输方式，这里有一个协议,`UDP(User Datagram Protocol)`

这个协议的格式很简单

```
[源端口号][目的端口号][数据]
```
还有一些校验字段，如果接收方收到数据，可以通过这些字段进行验证

封装好后数据就可以直接发送了

这其实有问题

> 对方是否真的接收到了?

自己无法知道

唯一的好处就是，通过这种协议是最简单的，所以也就是最快的

# TCP (Transmission Control Protocol)

针对UDP的不足，需要一种可以确保可靠的传输协议

### 如何确保可靠？

思路是这样的:

- 传输数据前，发送方和接收方先确定对方可以接收/发送数据
- 每发送一段数据，对方要回复一次，发送者可以明确得知对方已经收到该段数据,如果发送者没有收到明确回复，那么就得重发
- 发送者发送完成后，需要通知接接收方已经发送完毕
- 接收方接收完毕后，需要通知发送方已经接收完毕


### 其他问题

还有其他很多问题

- 如果网络比较拥堵，该怎么办?
- 无法找到接收方怎么办？
- 传递途中，数据损坏了怎么办？
- 端口号不对怎么办？

等等等

还有一个需求

发送者和接受者是可以互相发送数据的，也就是说这得是双工通信的协议

这就导致TCP协议是异常复杂的一个协议，可以说是所有协议中最复杂的


但是简单来说，主要流程就三步

- 建立链接
- 传输数据
- 关闭连接


# 建立链接(三次握手)

TCP协议的第一步就是建立链接

如何建立链接

比如a给b发送数据

- 1、a发送一个`发送数据请求`给b
- 2、b收到该请求(此时a可以确定b已经准备好了)，回复`可以发送数据请求`
- 3、a收到b的回复，还需要给b回复消息(b收到消息后，b才可以确定a也准备好了)

通过三步，双方都可以确定对方已经准备好了

这里有几个问题

### 如果超时了怎么办?

那么需要tcp有一个超时机制

实现方式也简单，a如果发送了一个消息，在设定的时间内没有回复，就从新发送数据，重复一定次数后，还没有回复，就表示无法建立连接

### 如果b收到的是一个超时的数据怎么办? 

思路是在数据中添加验证超时的字段

### 发送的数据为什么可以表示请求连接?

TCP数据包中，还得有字段，表明该请求是什么类型

常见的有

- SYN:synchronize
- ACK:Acknowledgement
- FIN:finish
- RST:reset

### SYN
序列号,tcp每次的数据量有限，所以遇到大的数据的时候，需要分开发送

syn表示的就是数据包的序号

发送的时候每个包都有一个序号，接收的时候，就按照序号，重新组装数据

### ACK

回复码，ACK(1000)就表示1000之前的数据包已经接收到了

### FIN
此次请求是关闭连接的请求

### RST

TCP连接出问题了，需要重新建立tcp连接


三次握手可以简单表示为

- SYN(0)
- ACK(1)
- ACK(1)

# 传输数据

传输的过程，就批量发送,比如

```
SYN(1):发送的是数据包1
ACK(2):数据包2之前的收到，请发送数据包2
SYN(3)
ACK(4)
```
因为网络的问题，也不一定是这种情况，比如

```
SYN(1)
SYN(2)
SYN(3)
SYN(4)
SYN(6)
ACK(5)
SYN(6)
SYN(7)
```
也就是说，不一定是一发一回复的，可能多个发送才有一个回复

但是发送过程中，还有一些问题

#### SYN FLOOD

这种攻击是一种`DDOS`攻击，也就是发送大量的syn数据，让接收方接收，来不及接收的时候，服务器也就无法正常工作了

### 慢启动

按理说，刚开始发送的时候，一次性都发出去最好

但是这样有问题

- 万一网络不好
- 对方来不及接收

等等问题，可能会导致白白发送数据

解决方式是，刚开始发送的时候，发送少量的数据，如果都在规定的时间内收到，那么就可以大批量发送了

### 滑动窗口

接收的数据都是放到缓冲区的，缓冲区大小有限8k左右，如果接收不过来的话，会直接抛弃

那换句话说，tcp应该是有一套处理方式，接收方接收不过来的时候，就少发送数据

tcp的处理方式是提供一个数据段`windows size(窗口大小)`,表示每次传送的最大数据大小

如果接收不过来，那么回复的时候，就将此数据段设置的小一些


# 关闭连接(四次握手)

- 1、a发送fin数据
- 2、b收到该fin数据，表示a已经发送完成，a不会再发送了
----------------
这个时候，虽然a已经不发送数据了，但是，b还是可以给a发送数据的
所以这个时候处于的是`半关闭`状态
----------------

- 3、b发送fin数据，表示b已经发送完数据了(或者压根就没发数据)
- 4、a收到b的fin数据，表示b已经发送完成，不会在发送数据了

通过这四步，双方才可以确保对方都关闭了连接






# 如果把链接建立好了，会一直连着吗

不会，如果一直连着，会白白浪费资源，那么会是多长时间呢?

`tcp默认是发送完成后就关闭了`

但是提供一个数据段`KeepAlive`可以设置发送完毕后多长时间再关闭连接

这个字段可以通过上层应用来设置的

操作系统默认提供了三个变量来设置

```
1.net.ipv4.tcpkeepaliveintvl = 75
2.net.ipv4.tcpkeepaliveprobes = 9
3.net.ipv4.tcpkeepalivetime = 7200
```
- tcpkeepalivetime的单位是秒，表示TCP链接在多少秒之后没有数据报文传输启动探测报文; 
- tcpkeepaliveintvl单位是也秒,表示前一个探测报文和后一个探测报文之间的时间间隔
- tcpkeepaliveprobes表示探测的次数

Ubuntu系统默认时间是`7200s`，2个小时没有数据传输后，才开始检测连接状态

这就是TCP的`heart beat(心跳检测)`


http请求中的`keep-alive`就是设置tcp的的这个数据段的，http本身没有这个功能

这个时间也可以在ngix，apache中设置



# 总结

综上所说，tcp至少应该包含以下字段

- 源port
- 目标port
- 标识位(syn/ack/fin/rst)
- window size位
- 数据验证位
- 数据

TCP协议比所说的还要复杂，这里只说简单的原理


# LINKS

- [https://zhongfox.github.io/2016/11/30/http-keep-alive/](https://zhongfox.github.io/2016/11/30/http-keep-alive/)
- [http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html](http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html)