---
title: 链表
categories: 
- DATASTRUCTOR
---



# LINKEDLIST


链表是线性表的一种,是`分散存储的线性表`

解决了顺序表的插入和删除不方便的问题

C中没有实现与之对应的实现，需要自己手动实现

# 实现

分散存储这个很好实现,`malloc`即可

有序这个目标的实现就是每个item自身带有下一个item的地址，如果是最后一个，那么地址就为null

```
[nextPointer,data] ---- [nextPointer,data]------[null,data]
```


# 增删改查

增加和删除会变得非常方便,但是要分成两步
- 删除元素
- 修改直接前驱或者直接后驱的nextPointer

排序的话，效率就没有顺序表高了，查找同样

在链表中，查找只能从头一个一个查找，无法像顺序表指定编号查找



# 优缺点

- 顺序表
    - 优点:查找，修改效率高
    - 缺点:长度固定，删除，修改效率低
- 链表
    - 优点:长度不固定，增加，删除效率高
    - 缺点:查找，修改效率低

----------------
有没有一种数据结构，能总和这两种数据结构的优点呢?

## 静态链表

静态链表

- 开辟一块足够大的空间,比如`int data[100];`,专门存放数据，但是存放的顺序没有规定
- 每一项的数据结构是这样的`[下一个item存放在data的索引,数据]`,比如`[12,3]-[15,6]-[18,88]`
- 读取数据的时候，第一个就是`data[0]`,下一个就是`data[0][下一个item存放在data的索引]`
- 通过data的索引，就可以非常方便的找到下一个元素

但是静态链表还是有那个缺陷，数据固定

--------------
其实有一个简单粗暴的方法，也许更合适

- 申请一块空间当作静态链表使用
- 如果发现静态链表空间不够用了，那么就再次申请一个两倍大小的空间
- 整体复制静态链表，然后再进行操作

# 变形版本

####  循环链表

链表是可以头尾相连，形成一个环的，有很多用处

比如`俄罗斯轮盘`

一个循环链表，都是空的，只有一个是有子弹的，每次操作，就读取下一个

#### 双向链表

之前的链表都是只有一个指向下一个的指针，也就是说，一个元素，它只知道下一个是谁，但是不知道上一个是谁，可能无法满足某些需求

于是就有了双向链表，思路很简单

```
[nextPointer,data,nextPointer]
```
使用两个指针

