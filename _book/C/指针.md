---
title: 指针
categories: 
- C
---

- [内存](#内存)
- [指针](#指针)
- [作用](#作用)
- [分类](#分类)

# 内存

内存是有编号的，一个编号对应一个的存储空间

编号最大值是2的32次方(32位系统),也就4G，

64位操作系统对应的最大空间就很大了


这个编号可能用不完，也可能不够用，但是操作系统最大就能识别这么多


比如
```
char c='c'
```

变量名默认指向的是这个存储空间，通过这个存储空间，也可以得到这个存储空间的编号

而这个编号，就是`地址`

# 指针

指针就是地址，只是不同的叫法而已，本质相同，就是一个编号而已，本质上就是一个数字


```
int a=1;
int *p=&a;
printf("%d\n",*p);
```
&表示取得对应变量的地址
*表示取得指针对应的数值




# 作用

操作一个数据，可以直接修改存储空间，也可以通过编号找到存储空间，然后修改

优势有很多

- 1、只存储地址，占用空间少
- 2、大数据操作，如果通过普通变量，一是栈空间放不下，二是出栈入栈效率低

C中绝大部分都是在操作内存，通过指针，达到内存管理的目的


# 分类

## 指针分类
指针本身只是存放内存地址，大小是固定的，也许认为没有必要进行分类，比如都定义为int类型

但是

```
char name='a';

int* p=&name;//将一个存储char类型的数据的地址赋给指针，这一步没有问题

printf("%c",*p);//但是到这个地方就有问题了，p如果是int类型的指针，那么就应该取4bit的数据，将这里面的数据当作整数看待，但实际上本意是存储字符，只需要1bit,这就不对了

//也就是说，指针分类型，不是为了存储使用的，而是为了指针取值的时候，知道到底该取多少bit用的

```
这里就涉及到一个概念

### 指针步长

char  类型的指针的步长就是1bit
int  类型的指针的步长就是4bit


### 空指针

一个指向NULL的指针叫做空指针

NULL是什么？

```
#define NULL ((void *)0)
```
看定义可以看到这是一个void类型的指针，这个指针的具体数值是0，也就是指向内存编号为0 的指针

也就是说，空指针表示指向内存编号为0的指针

有什么用？

一般是防止野指针的产生，野指针的出现绝大多数意味着可能出错，所以将指针归零

### 野指针

```
int* p=123456;
```
野指针就是指针指向的地址是未知的

如上，编号123456的这个内存存放的东西是什么我不知道，虽然语法上没有问题，但是没有什么实际意义

### 万能指针

```
char* name=123456;

int* age=456789;


name=age;//类型不同的指针是不能够赋值的，虽然都是32/64bit长度，但是指针步长不同，导致后期*操作错误

void* wanneng;

wanneng=name;//万能指针可以接收随便的指针

printf("%c",(char*)wanneng);//但是在使用的时候需要转换成对应的类型，否则也是没法确定步长

```

万能指针，也叫做 无类型指针



### 多级指针

C 中可以使用多级指针

```
char name='a';
char *p=&a;
char **pp=p;

printf("%p",pp);//pp指针自己的地址
printf("%p",*pp);//p指针存储的内容，也就是name的地址
printf("%p",**pp);//name的数值


```
C中大量使用多级指针，但是一般最多就两级指针，因为两级指针就可以实现调用参数来修改数据了


# 指针和数组

```
int arr[]={1,2,3};

int* p=&arr;

printf("%p\n",arr);
printf("%p\n",p);
printf("%p\n",&arr[0]);
```
这三个地址相同

由此可以推出

数组的本质就是

1、开辟一段连续的内存

2、给这段内存取一个变量名称`arr`

3、将第一个数据项的地址赋值给`arr`

但是这些数据都是放到栈区的

知道数组的本质，那么如何在堆区中模拟使用数组呢？


```
#include<stdio.h>

void main()
{	
	int * arr = malloc(sizeof(int) * 3);//堆区开辟3个int空间

	*(arr + 0) = 4;//给第一个int空间赋值为4
	*(arr + 1) = 5;
	*(arr + 2) = 6;

	for (size_t i = 0; i < 3; i++)
	{
		printf("%d\n", *(arr + i));
	}

    free(arr);//释放堆空间
	
	getchar();
}

```

也可以使用数组的方式进行操作

```

#include<stdio.h>
#include<stdlib.h>
#include<time.h>


void main()
{	
	int * arr = malloc(sizeof(int) * 3);

	arr[0] = 4;
	arr[1] = 5;
	arr[2] = 6;

	for (size_t i = 0; i < 3; i++)
	{
		printf("%d\n", arr[i]);
	}
	free(arr);
	
	getchar();
}


```
可以观察
```
arr[1] = 4;

*(arr+sizeof(char))=4;
```
这两种写法，本质是一样的

可以得出结论

[]本质上就是*操作，是C提供的一种语法糖


由于栈区空间有限，所以，大部分的数组，都应该使用这种模拟方式，放到堆区中


#指针和字符串

字符串本质上就是一种特殊的数组，所以和数组很相似

但是使用上还是有些别扭


比如函数参数，在其他语言中，可能使用string这种类型

比如

```
voin test(string name){}
```
但是在C中，则需要使用指针来传递字符串

```
voin test(char* name){}
```

也就是说，在C中，字符串，数组都是传地址的，可以修改原来的数据

```
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

void test(char * name) {

	name[3] = 't';
	printf("%s", name);
}

void main()
{	
	char name[] = "hello";

	test(name);
	
	printf("%s", name);
	getchar();
}
```

