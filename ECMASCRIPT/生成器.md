---
title: 生成器
categories: 
- ECMASCRIPT
---

# 生成器


虽然自定义的迭代器是一个有用的工具，但由于需要显式地维护其内部状态，因此需要谨慎地创建。

Generators提供了一个强大的选择：它允许你定义一个包含自有迭代算法的函数， 同时它可以自动维护自己的状态。

生成器是在迭代器的基础上建立的，有一套自己独立的语法和规则

js中，使用`Generator`对象表示生成器

简单说，generator就是`可以自己控制遍历的迭代器`


# generator function(生成器函数)

生成一个Generator有自己的一套独立的语法


### function* 


function加上*表示一个专门用来生成一个generator的函数，这个函数有自己独特的语法


```
function* gen(){}
let g=gen();
```
返回的generator对象，和普通的迭代器结构上没有什么不同

但是他可以自己控制遍历，简单说就是可以暂停遍历


### yeild

generator函数中可以使用`yield`关键词

-------------

每当generator调用一次next()方法时候，会执行到第一个yield 表达式，并返回yield后面的表达式的运算结果

注意,比如`let c=yield 3`;

gengerator函数只会执行yield表达式，这个时候变量C并不会创建

返回值则是符合`迭代器协议`的对象，格式是`{value:value,done:true/false}`

- value的值:yield后面的表达式的运算结果
- done:如果后面没有yield，则为true，表示迭代结束，否则就为false

---------------------

第二次执行next()方法，和第一次类似

只不过next()方法可以传递参数，表示`yield表达式的值`


### yield*

yield*表示将执行权移交给另一个生成器函数（当前生成器暂停执行）

# 总结

- 生成器是一种特殊的迭代器
- 生成器的特殊体现在可以自己控制迭代进度
- 生成器有自己的一套语法

迭代器和生成器不需要而外的线程来配合，和promise不一样，主线程只需要记忆住迭代的进度即可

也就是说，迭代器和生成器都是同步代码


# Generator.prototype.next()
返回一个由 yield表达式生成的值。