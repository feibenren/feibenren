---
title: 事件循环
categories: 
- NODEJS
---

# 事件循环(event loop)


```
  ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```


- 1、定时器：本阶段执行已经安排的 setTimeout() 和 setInterval() 的回调函数。
- 2、待定回调：执行延迟到下一个循环迭代的 I/O 回调。
- 3、idle, prepare：仅系统内部使用。
- 4、轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate() 排定的之外），其余情况 node 将在此处阻塞。
- 5、检测：setImmediate() 回调函数在这里执行。
- 6、关闭的回调函数：一些准备关闭的回调函数


# timers



# pending callbacks

This phase executes callbacks for some system operations such as types of TCP errors


# poll

If the poll queue is not empty, the event loop will iterate through its queue of callbacks executing them synchronously until either the queue has been exhausted, or the system-dependent hard limit is reached.

如果`轮询队列`不为空，那么就会迭代执行`轮询队列`

直到队列为空，或者系统设置的最大极限

------------------

If the poll queue is empty, one of two more things will happen:

If scripts have been scheduled by setImmediate(), the event loop will end the poll phase and continue to the check phase to execute those scheduled scripts.

If scripts have not been scheduled by setImmediate(), the event loop will wait for callbacks to be added to the queue, then execute them immediately.


如果循环队列为空，有两种情况

- 如果有`setImmediate()`，则会调到下一个阶段
- 如果没有`setImmediate()`，则就静默等待，直到回调函数被添加到队列中


# check

This phase allows a person to execute callbacks immediately after the poll phase has completed. 


# close callbacks




# process.nextTick()

process.nextTick() is not technically part of the event loop.


 the nextTickQueue will be processed after the current operation is completed, regardless of the current phase of the event loop. 


 Looking back at our diagram, any time you call process.nextTick() in a given phase, all callbacks passed to process.nextTick() will be resolved `before the event loop continues`. 


- 当前操作执行完成，就会执行`nextTickQueue`
- event loop开始前，就会执行`process.nextTick()`




This can create some bad situations because it allows you to "starve" your I/O by making recursive process.nextTick() calls, which prevents the event loop from reaching the poll phase.



Why would that be allowed?





# 对比浏览器

# 总结

event loop 首先会在内部维持多个事件队列，比如 时间队列、网络队列等等



the nextTickQueue will be processed after the current operation is completed, regardless of the current phase of the event loop


# links

-[https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/](https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/)

- [https://github.com/kaola-fed/blog/issues/234](https://github.com/kaola-fed/blog/issues/234)