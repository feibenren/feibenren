---
title: CHARSET
categories: 
- COMPUTER
---
# charset(字符编码)到底是什么东西?

先来说说这几个概念

### 字符

比如汉字`你`,英语`A`,使用特定的图形表示特定的意思，这个图形就是字符，不同语言的字符不一样

### 字符集

字符集那就是一个特定的字符的集合，比如汉字字符集,表示的就是所有的汉字的集合，英语字符集，表示的就是所有英文字母的集合


但是在计算机中无法存储这些字符集，只能使用01来表示，也就是说，需要使用`数字来表示图形(字符)`

那也简单，一一编号即可

对应的编号就叫做`编码字符集`

刚开始各个国家搞各自的字符集，比如`ASCII`就是拉丁字母字符集，中国人自己搞的字符集`GBK`

这就导致一个问题，那就是会乱码，如果按照GBK的方式打开ASCII的编码，会乱码

最后得出共识，全球的字符都放到一个编码表中，就不会出现乱码

刚开始有两个团队在做这个编码表，`UNICODE`和`UCS`，后来两个合并成`UNICODE`

`UNICODE`，收录了全球几乎所有的字符,一共有2的21次方个字符，并且可能会随时增加，也就是`100万`个字符左右

UNICODE的收录方式是分类收录的，有这几个概念

- code point(码点):一个编号就是一个码点
- plane(平面):一个plane是2的16次方(65536)个,一共有2的5次方个(17)plane，所以一共有2的21的字符
- BMP:基本平面,是第一个plane，这里面收录全球最最常用的字符
- SMP:辅助平面，第二到第17个plane，里面收录的全球是非常用的字符



# 字符编码(charset)

unicode最是定义了编号，具体怎么存储？

最简单的思路，逐个对应

## UTF-32

使用2的32次方来对应UNICODE，绰绰有余，也就是4byte对应一个`code point`

简单明了

## UTF-8

但是使用utf-32有一个问题，那就是太浪费存储空间，如果只存储英文字母的话，使用ASCII来存储，1byte就表示一个字符

使用UTF-32存储的话，就会扩大4倍的空间

utf-8解决了这个问题，它使用变长存储字符


- 如果一个字节的第一位为0，那么代表当前字符为单字节字符，占用一个字节的空间。0之后的所有部分（7个bit）代表在Unicode中的序号。

- 如果一个字节以110开头，那么代表当前字符为双字节字符，占用2个字节的空间。110之后的所有部分（5个bit）加上后一个字节的除10外的部分（6个bit）代表在Unicode中的序号。且第二个字节以10开头
- 如果一个字节以1110开头，那么代表当前字符为三字节字符，占用3个字节的空间。110之后的所有部分（5个bit）加上后两个字节的除10外的部分（12个bit）代表在Unicode中的序号。且第二、第三个字节以10开头
- 如果一个字节以10开头，那么代表当前字节为多字节字符的第二个字节。10之后的所有部分（6个bit）和之前的部分一同组成在Unicode中的序号。

```
Byte 1	    Byte 2	    Byte3
0xxx xxxx	 	 
110x xxxx	10xx xxxx	 
1110 xxxx	10xx xxxx	10xx xxxx
```

UTF-8规则稍微复杂一些，主要就是为了实现变长字符，最大化的节省存储空间







按照UNICODE的设想挺好，但是实现起来，很不划算，因为存储一个字符要20个bit，并且这里面绝大部分，都是自己更本用不到的，只有很少的东西才能用到，比如英文国家，之前就8个bit就可以表示一个字符，但是现在要用20个bit表示，会浪费很多空间

解决的方法也很简单

我制作一个字符集，只表示常用的字符，就可以了，不表示所有的，在存储空间和表示范围折中，其中的代表就是`UTF-16`

# UTF-16

utf-16的设计思路很简单，挑出常用的字符，使用16bit来表示就可以了

也就是最多65536个字符,6万多个

由于这种字符太常用，所以几乎所有的计算机语言都默认使用这种编码，而且有一个稍微有些歧义的名称`unicode编码`





# UTF-8

UTF-8实现了unicode的一部分，具体实现方式:





-------------

所以，charset到底是什么意思，其实就是一种编码方式

我们平时是接触不到字符库的，我们接触到的只能是charset

# 乱码

这个也好理解，比如字符`a`,使用utf8编码，存储起来是`001`

如果使用`GBK`编码方式来打开这个文件,可能对应的是字符`你`,

这就是乱码的原因


# 常见的charset有哪些?

- ASCII
- GBK
- GB2312
- UTF-8(Unicode Transformation Format)

还有一种charset可能会有歧义，那就是`unicode`

unicode表示的所有的字符的集合，但是也有一种具体的实现方式

但是这个unicode charset也没有实现全部的字符，而一共使用了`16bit`来表示字符，基本够用






# base64


还有一种编码方式比较特殊，

那就是针对二进制文件的编码，这种编码方式不应该算是一种`charset`，因为二进制文件不是`char`

思路是这样的

- 使用64个字符(a-zA-Z0-9+-=)
- 每三个字节一组(24bit)
- 分成四分，每份前面补充两个0，一共32bit
- 每一份，因为前面是两个0，所以实际有意义是的6位,也就是64
- 使用对应的字符来标示每一位即可

可以看到，由于添加了0，使得3byte变成了4byte，数据变大了三分之一左右










摩斯电码

ASCII


# LINKS

- [http://cenalulu.github.io/linux/character-encoding/](http://cenalulu.github.io/linux/character-encoding/)
- [http://www.ruanyifeng.com/blog/2014/12/unicode.html](http://www.ruanyifeng.com/blog/2014/12/unicode.html)
- [http://www.ruanyifeng.com/blog/2014/12/unicodejavascript.html](http://www.ruanyifeng.com/blog/2014/12/unicodejavascript.html)
- [http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)